' @module BGE
namespace BGE

  ' TODO: figure this out... is useful for sprites with different size frames
  function TexturePacker_GetRegions(atlas as dynamic, bitmap as ifDraw2d) as roAssociativeArray
    if type(atlas) = "String" or type(atlas) = "roString"
      atlas = ParseJson(atlas)
    end if
    regions = {}
    for each key in atlas.frames
      item = atlas.frames[key]

      region = CreateObject("roRegion", bitmap, item.frame.x, item.frame.y, item.frame.w, item.frame.h)

      if invalid <> item and invalid <> item.pivot
        translation_x = item.spriteSourceSize.x - item.sourceSize.w * item.pivot.x
        translation_y = item.spriteSourceSize.y - item.sourceSize.h * item.pivot.y
        region.SetPretranslation(translation_x, translation_y)
      end if

      regions[key] = region
    end for

    return regions
  end function


  ' -----------------------Utilities Used By Game Engine---------------------------

  function ArrayInsert(array as dynamic[], index as integer, value as dynamic) as dynamic[]
    for i = array.Count() to index + 1 step -1
      array[i] = array[i - 1]
    end for
    array[index] = value
    return array
  end function

  sub DrawCircleOutline(draw2d as ifDraw2d, line_count as integer, x as float, y as float, radius as float, rgba as integer)
    if draw2d = invalid
      return
    end if
    previous_x = radius
    previous_y = 0
    for i = 0 to line_count
      degrees = 360 * (i / line_count)
      current_x = cos(degrees * .01745329) * radius
      current_y = sin(degrees * .01745329) * radius
      draw2d.DrawLine(x + previous_x, y + previous_y, x + current_x, y + current_y, rgba)
      previous_x = current_x
      previous_y = current_y
    end for
  end sub


  sub DrawRectangleOutline(draw2d as ifDraw2d, x as float, y as float, width as float, height as float, rgba as integer)
    if draw2d = invalid
      return
    end if
    draw2d.DrawLine(x, y, x + width, y, rgba)
    draw2d.DrawLine(x, y, x, y + height, rgba)
    draw2d.DrawLine(x + width, y, x + width, y + height, rgba)
    draw2d.DrawLine(x, y + height, x + width, y + height, rgba)
  end sub




  function isValidEntity(entity as EntityWithId) as boolean
    return invalid <> entity and entity.id <> invalid
  end function


  ' 	' -------Button Code Reference--------
  ' 	' Button  Pressed Released  Held
  '   ' ------------------------------
  ' 	' Back         0      100   1000
  ' 	' Up           2      102   1002
  ' 	' Down         3      103   1003
  ' 	' Left         4      104   1004
  ' 	' Right        5      105   1005
  ' 	' OK           6      106   1006
  ' 	' Replay       7      107   1007
  ' 	' Rewind       8      108   1008
  ' 	' FastForward  9      109   1009
  ' 	' Options     10      110   1010
  ' 	' Play        13      113   1013

  function buttonNameFromCode(buttonCode as integer) as string
    buttonId = buttonCode mod 100
    possibleButtonNames = [
      "back",
      "unknown",
      "up",
      "down"
      "left",
      "right",
      "OK",
      "replay",
      "rewind",
      "fastforward",
      "options",
      "audioguide",
      "unknown",
      "play"
    ]
    if buttonId < possibleButtonNames.count()
      return possibleButtonNames[buttonId]
    end if
    return invalid
  end function

  ' Clone an array (shallow)
  '
  ' @param {dynamic[]} [original=[]] the original array to be clones
  ' @return {dynamic[]} A shallow copy of the original array
  function cloneArray(original = []) as dynamic[]
    retVal = []
    for each item in original
      retVal.push(item)
    end for
    return retVal
  end function

  ' Check if two arrays of points are teh same - that is, if each point, in order has same x and y values
  '
  ' @param {object} [a=[]] the first array
  ' @param {object} [b=[]] the second array
  ' @return {boolean} true if both arrays have same number of points and x and y values are the same for each point
  function pointArraysEqual(a = [] as PositionXY[], b = [] as PositionXY[]) as boolean
    if a.count() <> b.count()
      return false
    end if

    same = true

    for i = 0 to a.count() - 1
      same = a[i].x = b[i].x and a[i].y = b[i].y
      if not same
        exit for
      end if
    end for

    return same
  end function



  function isTrue(value) as boolean
    return rodash.isBoolean(value) and value = true
  end function


  function bytesToInteger(bytes as integer[] or roByteArray, offset = 0, isLittleEndian = true) as integer
    if invalid = bytes or bytes.Count() < offset + 4
      return 0
      '  throw "Invalid input to BGE.bytesToInteger()"
    end if
    if isLittleEndian
      b0 = (bytes[0 + offset] and &hFF) as integer
      b1 = (bytes[1 + offset] and &hFF) as integer
      b2 = (bytes[2 + offset] and &hFF) as integer
      b3 = (bytes[3 + offset] and &hFF) as integer
    else
      b0 = (bytes[3 + offset] and &hFF) as integer
      b1 = (bytes[2 + offset] and &hFF) as integer
      b2 = (bytes[1 + offset] and &hFF) as integer
      b3 = (bytes[0 + offset] and &hFF) as integer
    end if
    result = b0 + (b1 << 8) + (b2 << 16) + (b3 << 24)
    return result
  end function

  function bytesToFloat(bytes as integer[] or roByteArray, offset = 0, isLittleEndian = true) as float
    if invalid = bytes or bytes.Count() < offset + 4
      return 0
      '    throw "Invalid input to BGE.bytesToFloat()"
    end if
    if isLittleEndian
      b0 = (bytes[0 + offset] and &hFF) as integer
      b1 = (bytes[1 + offset] and &hFF) as integer
      b2 = (bytes[2 + offset] and &hFF) as integer
      b3 = (bytes[3 + offset] and &hFF) as integer
    else
      b0 = (bytes[3 + offset] and &hFF) as integer
      b1 = (bytes[2 + offset] and &hFF) as integer
      b2 = (bytes[1 + offset] and &hFF) as integer
      b3 = (bytes[0 + offset] and &hFF) as integer
    end if
    sign = (b3 and &h80) ? - 1 : 1
    exponent = (((b3 and &h7F) as integer) << 1) or (((b2 and &h80) as integer) >> 7) as integer
    fraction = (((b2 and &h7F) as integer) << 16) or (b1 << 8) or b0

    if (exponent = 0 and fraction = 0)
      return 0.0 ' Exponent and fraction are zero, return + / -0
    else if (exponent = &hFF and fraction = 0)
      return sign * 999999999 ' Exponent is all ones and fraction is zero, return + / -Infinity
    else if (exponent = &hFF)
      return 0
      'throw "bytesToFloat() - Evaluates to NaN"
    end if

    mantissa = 1 + (fraction / BGE.Math.Power(2, 23))
    value = sign * mantissa * BGE.Math.Power(2, exponent - 127)
    return value
  end function


  function subArray(array as ifArray, startIndex, length as integer) as roArray
    result = []
    for i = startIndex to startIndex + length - 1
      result.push(array[i])
    end for
    return result
  end function


  function decToHex(dec as integer) as string
    hexTab = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"]
    hex = ""
    while dec > 0
      hex = hexTab [dec mod 16] + hex
      dec = dec / 16
    end while
    if hex = "" return "0" else return hex
  end function

end namespace



