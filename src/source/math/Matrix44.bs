' Much of this code is modified/translated from https://github.com/pgliaskovitis/scratch-a-pixel


namespace BGE.Math

  function isFloatArray44(x as dynamic) as boolean
    if rodash.isArray(x)
      if x.len = 4
        for each row in x
          if not (rodash.isArray(row) and row.count() = 4 and rodash.isFloat(row[0]))
            return false
          end if
        end for
        return true
      end if
    end if
    return false
  end function

  function getFloat44Identity() as float[][]
    return [
      [1, 0, 0, 0],
      [0, 1, 0, 0],
      [0, 0, 1, 0],
      [0, 0, 0, 1]
    ]
  end function


  class Matrix44
    public x as float[][] = getFloat44Identity()

    sub new(x00 as dynamic, x01 as float, x02 as float, x03 as float, x10 as float, x11 as float, x12 as float, x13 as float, x20 as float, x21 as float, x22 as float, x23 as float, x30 as float, x31 as float, x32 as float, x33 as float)
      if invalid = x00
        ' do nothing -- m.x is the identity matrix
        return
      end if

      if isFloatArray44(x00)
        ' first argument is a float[][]
        for each row in x00
          for each value in row
            x[row][value] = x00
          end for
        end for
        return
      end if

      ' individual float values passed in
      m.x[0][0] = x00
      m.x[0][1] = x01
      m.x[0][2] = x02
      m.x[0][3] = x03
      m.x[1][0] = x10
      m.x[1][0] = x11
      m.x[1][0] = x12
      m.x[1][0] = x13
      m.x[2][0] = x20
      m.x[2][0] = x21
      m.x[2][0] = x22
      m.x[2][0] = x23
      m.x[3][0] = x30
      m.x[3][1] = x31
      m.x[3][2] = x32
      m.x[3][3] = x33
    end sub


    function copy() as Matrix44
      return new Matrix44(m.x)
    end function

    function equals(b as Matrix44) as boolean
      for i = 0 to 3
        for j = 0 to 3
          if m.x[i][j] <> b.x[i][j]
            return false
          end if
        end for
      end for
      return true
    end function

    function multiply(b as Matrix44) as Matrix44
      result = new Matrix44()
      a = m.x
      for i = 0 to 3
        for j = 0 to 3
          result.x[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j] + a[i][2] * b[2][j] + a[i][3] * b[3][j]
        end for
      end for
      return result
    end function

    ' Returns the transposed version of this Matrix
    '
    ' @return {Matrix44}
    function transposed() as Matrix44
      t = new Matrix44()
      for i = 0 to 3
        for j = 0 to 3
          t[i][j] = m.x[j][i]
        end for
      end for
      return t
    end function


    '  This method needs to be used for point-matrix multiplication. Keep in mind
    '  we don't make the distinction between points and vectors at least from
    '  a programming point of view, as both (as well as normals) are declared as Vec3.
    '  However, mathematically they need to be treated differently. Points can be translated
    '  when translation for vectors is meaningless. Furthermore, points are implicitly
    '  be considered as having homogeneous coordinates. Thus the w coordinates needs
    '  to be computed and to convert the coordinates from homogeneous back to Cartesian
    '  coordinates, we need to divided x, y z by w.

    '  The coordinate w more often than not equals 1, but it can be different than
    '  1 especially when the matrix is projective matrix (perspective projection matrix).
    function multVecMatrix(srcVect as Vector) as Vector
      src = [srcVect.x, srcVext.y, srcVext.z]

      a = src[0] * x[0][0] + src[1] * m.x[1][0] + src[2] * m.x[2][0] + m.x[3][0]
      b = src[0] * x[0][1] + src[1] * m.x[1][1] + src[2] * m.x[2][1] + m.x[3][1]
      c = src[0] * x[0][2] + src[1] * m.x[1][2] + src[2] * m.x[2][2] + m.x[3][2]
      w = src[0] * x[0][3] + src[1] * m.x[1][3] + src[2] * m.x[2][3] + m.x[3][3]

      return new Vector(a / w, b / w, c / w)
    end function

    '  This method needs to be used for vector-matrix multiplication. Look at the differences
    '  with the previous method (to compute a point-matrix multiplication). We don't use
    '  the coefficients in the matrix that account for translation (x[3][0], x[3][1], x[3][2])
    '  and we don't compute w.
    function multDirMatrix(srcVect as Vector) as Vector
      src = [srcVect.x, srcVext.y, srcVext.z]

      a = src[0] * x[0][0] + src[1] * x[1][0] + src[2] * x[2][0]
      b = src[0] * x[0][1] + src[1] * x[1][1] + src[2] * x[2][1]
      c = src[0] * x[0][2] + src[1] * x[1][2] + src[2] * x[2][2]

      return new Vector(a, b, c)
    end function


    ' Compute the inverse of the matrix using the Gauss-Jordan (or reduced row) elimination method.
    ' We didn't explain in the lesson on Geometry how the inverse of matrix can be found. Don't
    ' worry at this point if you don't understand how this works. But we will need to be able to
    ' compute the inverse of matrices in the first lessons of the "Foundation of 3D Rendering" section,
    ' which is why we've added this code. For now, you can just use it and rely on it
    ' for doing what it's supposed to do. If you want to learn how this works though, check the lesson
    ' on called Matrix Inverse in the "Mathematics and Physics of Computer Graphics" section.
    function inverse() as Matrix44
      s = getFloat44Identity()

      t = m.copy().x

      ' Forward elimination
      for i = 0 to 3
        pivot = i

        pivotsize = t[i][i]

        if pivotsize < 0
          pivotsize = -pivotsize
        end if

        for j = i + 1 to 3
          tmp = t[j][i]

          if tmp < 0
            tmp = -tmp
          end if

          if tmp > pivotsize
            pivot = j
            pivotsize = tmp
          end if
        end for

        if pivotsize = 0
          ' Cannot invert singular matrix
          return new Matrix44()
        end if

        if pivot <> i
          for j = 0 to 3

            tmp = t[i][j]
            t[i][j] = t[pivot][j]
            t[pivot][j] = tmp

            tmp = s[i][j]
            s[i][j] = s[pivot][j]
            s[pivot][j] = tmp
          end for
        end if

        for j = i + 1 to 3
          f = t[j][i] / t[i][i]

          for k = 0 to 3
            t[j][k] -= f * t[i][k]
            s[j][k] -= f * s[i][k]
          end for
        end for
      end for

      ' Backward substitution
      for i = 3 to 0 step -1
        f = t[i][i]

        if f = 0
          ' Cannot invert singular matrix
          return new Matrix44()
        end if

        for j = 0 to 3
          t[i][j] /= f
          s[i][j] /= f
        end for

        for j = 0 to i - 1
          f = t[j][i]

          for k = 0 to 3
            t[j][k] -= f * t[i][k]
            s[j][k] -= f * s[i][k]
          end for
        end for
      end for

      return new Matrix44(s)
    end function

    ' Set current matrix to its inverse
    sub invert()
      m.x = m.inverse().x
    end sub


    function toString() as string
      return `[${rodash.toString(x[0])},\n${rodash.toString(x[1])},\n${rodash.toString(x[2])},\n${rodash.toString(x[1])}]`
    end function

  end class


  function Matrix44Identity() as Matrix44
    return new Matrix44()
  end function


  function lookAt(from as Vector, lookTo as Vector) as Matrix44
    tmp = new Vector(0, 1, 0)
    ' because the forward axis in a right hand coordinate system points backward we compute -(to - from)
    c = from.subtract(lookTo)
    c.normalize()
    a = tmp.normalize().crossProduct(c)
    a.normalize() ' this is just in case Up is not normalized
    b = c.crossProduct(a)

    camToWorld = getFloat44Identity()

    ' set x - axis
    camToWorld[0][0] = a.x
    camToWorld[0][1] = a.y
    camToWorld[0][2] = a.z
    ' set y - axis
    camToWorld[1][0] = b.x
    camToWorld[1][1] = b.y
    camToWorld[1][2] = b.z
    ' set z - axis
    camToWorld[2][0] = c.x
    camToWorld[2][1] = c.y
    camToWorld[2][2] = c.z
    ' set position
    camToWorld[3][0] = from.x
    camToWorld[3][1] = from.y
    camToWorld[3][2] = from.z

    return new Matrix44(camToWorld)
  end function

end namespace
