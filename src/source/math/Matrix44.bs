' Much of this code is modified/translated from https://github.com/pgliaskovitis/scratch-a-pixel


namespace BGE.Math

  function isFloatArray44(x as dynamic) as boolean
    if rodash.isArray(x)
      if x.count() = 4
        for each row in x
          if not (rodash.isArray(row) and row.count() = 4 and rodash.isNumber(row[0]))
            return false
          end if
        end for
        return true
      end if
    end if
    return false
  end function

  function getFloat44Identity() as float[][]
    dim matrix [3, 3]
    matrix[0][0] = 1
    matrix[0][1] = 0
    matrix[0][2] = 0
    matrix[0][3] = 0
    matrix[1][0] = 0
    matrix[1][1] = 1
    matrix[1][2] = 0
    matrix[1][3] = 0
    matrix[2][0] = 0
    matrix[2][1] = 0
    matrix[2][2] = 1
    matrix[2][3] = 0
    matrix[3][0] = 0
    matrix[3][1] = 0
    matrix[3][2] = 0
    matrix[3][3] = 1
    return matrix
  end function

  sub fillFloat44(dest as float[][], src as float[][])
    for i = 0 to 3
      for j = 0 to 3
        dest[i][j] = src[i][j] * 1.0
      end for
    end for
  end sub


  namespace Matrix44

    function create(values = invalid as float[][]) as float[][]
      matrix = BGE.Math.getFloat44Identity()
      if BGE.Math.isFloatArray44(values)
        ' first argument is a float[][]
        BGE.Math.fillFloat44(matrix, values)

      end if
      return matrix
    end function

    function copy(mat as float[][]) as float[][]
      return create(mat)
    end function

    function setFrom(mat as float[][], b as float[][]) as float[][]
      BGE.Math.fillFloat44(mat, b)
      return mat
    end function

    function equals(mat as float[][], b as float[][]) as boolean
      ' if m.mat[0][0] <> b.mat[0][0]
      '   return false
      ' else if m.mat[0][1] <> b.mat[0][1]
      '   return false
      ' else if m.mat[0][2] <> b.mat[0][2]
      '   return false
      ' else if m.mat[0][3] <> b.mat[0][3]
      '   return false
      ' else if m.mat[1][0] <> b.mat[1][0]
      '   return false
      ' else if m.mat[1][1] <> b.mat[1][1]
      '   return false
      ' else if m.mat[1][2] <> b.mat[1][2]
      '   return false
      ' else if m.mat[1][3] <> b.mat[1][3]
      '   return false
      ' else if m.mat[2][0] <> b.mat[2][0]
      '   return false
      ' else if m.mat[2][1] <> b.mat[2][1]
      '   return false
      ' else if m.mat[2][2] <> b.mat[2][2]
      '   return false
      ' else if m.mat[2][3] <> b.mat[2][3]
      '   return false
      ' else if m.mat[3][0] <> b.mat[3][0]
      '   return false
      ' else if m.mat[3][0] <> b.mat[3][0]
      '   return false
      ' else if m.mat[3][1] <> b.mat[3][1]
      '   return false
      ' else if m.mat[3][2] <> b.mat[3][2]
      '   return false
      ' else if m.mat[3][3] <> b.mat[3][3]
      '   return false
      ' end if
      ' return true

      for i = 0 to 3
        for j = 0 to 3
          if mat[i][j] <> b[i][j]
            return false
          end if
        end for
      end for
      return true
    end function

    function multiply(mat as float[][], operand as float[][]) as float[][]
      result = BGE.Math.getFloat44Identity()
      a = mat
      b = operand
      for j = 0 to 3
        result[0][j] = a[0][0] * b[0][j] + a[0][1] * b[1][j] + a[0][2] * b[2][j] + a[0][3] * b[3][j]
        result[1][j] = a[1][0] * b[0][j] + a[1][1] * b[1][j] + a[1][2] * b[2][j] + a[1][3] * b[3][j]
        result[2][j] = a[2][0] * b[0][j] + a[2][1] * b[1][j] + a[2][2] * b[2][j] + a[2][3] * b[3][j]
        result[3][j] = a[3][0] * b[0][j] + a[3][1] * b[1][j] + a[3][2] * b[2][j] + a[3][3] * b[3][j]
      end for
      return result
    end function

    ' Returns the transposed version of this Matrix
    '
    ' @return {Matrix44}
    function transposed(mat as float[][]) as float[][]
      result = BGE.Math.getFloat44Identity()
      for i = 0 to 3
        for j = 0 to 3
          result.mat[i][j] = m.mat[j][i]
        end for
      end for
      return result
    end function


    '  This method needs to be used for point-matrix multiplication. Keep in mind
    '  we don't make the distinction between points and vectors at least from
    '  a programming point of view, as both (as well as normals) are declared as Vec3.
    '  However, mathematically they need to be treated differently. Points can be translated
    '  when translation for vectors is meaningless. Furthermore, points are implicitly
    '  be considered as having homogeneous coordinates. Thus the w coordinates needs
    '  to be computed and to convert the coordinates from homogeneous back to Cartesian
    '  coordinates, we need to divided x, y z by w.

    '  The coordinate w more often than not equals 1, but it can be different than
    '  1 especially when the matrix is projective matrix (perspective projection matrix).
    function multVecMatrix(srcVect as Vector, mat as float[][]) as Vector
      srcX = srcVect.x
      srcY = srcVect.y
      srcZ = srcVect.z

      a = srcX * mat[0][0] + srcY * mat[1][0] + srcZ * mat[2][0] + mat[3][0]
      b = srcX * mat[0][1] + srcY * mat[1][1] + srcZ * mat[2][1] + mat[3][1]
      c = srcX * mat[0][2] + srcY * mat[1][2] + srcZ * mat[2][2] + mat[3][2]
      w = srcX * mat[0][3] + srcY * mat[1][3] + srcZ * mat[2][3] + mat[3][3]

      result = {x: a / w, y: b / w, z: c / w}
      return result
    end function

    '  This method needs to be used for vector-matrix multiplication. Look at the differences
    '  with the previous method (to compute a point-matrix multiplication). We don't use
    '  the coefficients in the matrix that account for translation (x[3][0], x[3][1], x[3][2])
    '  and we don't compute w.
    function multDirMatrix(srcVect as Vector, mat as float[][]) as Vector
      srcX = srcVect.x
      srcY = srcVect.y
      srcZ = srcVect.z

      a = srcX * mat[0][0] + srcY * mat[1][0] + srcZ * mat[2][0]
      b = srcX * mat[0][1] + srcY * mat[1][1] + srcZ * mat[2][1]
      c = srcX * mat[0][2] + srcY * mat[1][2] + srcZ * mat[2][2]

      return {x: a, y: b, z: c}
    end function


    ' Compute the inverse of the matrix using the Gauss-Jordan (or reduced row) elimination method.
    ' We didn't explain in the lesson on Geometry how the inverse of matrix can be found. Don't
    ' worry at this point if you don't understand how this works. But we will need to be able to
    ' compute the inverse of matrices in the first lessons of the "Foundation of 3D Rendering" section,
    ' which is why we've added this code. For now, you can just use it and rely on it
    ' for doing what it's supposed to do. If you want to learn how this works though, check the lesson
    ' on called Matrix Inverse in the "Mathematics and Physics of Computer Graphics" section.
    function inverse(mat as float[][]) as float[][]
      s = BGE.Math.getFloat44Identity()

      t = copy(mat)

      ' Forward elimination
      for i = 0 to 3
        pivot = i

        pivotsize = t[i][i]

        if pivotsize < 0
          pivotsize = -pivotsize
        end if

        for j = i + 1 to 3
          tmp = t[j][i]

          if tmp < 0
            tmp = -tmp
          end if

          if tmp > pivotsize
            pivot = j
            pivotsize = tmp
          end if
        end for

        if pivotsize = 0
          ' Cannot invert singular matrix
          return BGE.Math.getFloat44Identity()
        end if

        if pivot <> i
          for j = 0 to 3

            tmp = t[i][j]
            t[i][j] = t[pivot][j]
            t[pivot][j] = tmp

            tmp = s[i][j]
            s[i][j] = s[pivot][j]
            s[pivot][j] = tmp
          end for
        end if

        for j = i + 1 to 3
          f = t[j][i] / t[i][i]

          for k = 0 to 3
            t[j][k] -= f * t[i][k]
            s[j][k] -= f * s[i][k]
          end for
        end for
      end for

      ' Backward substitution
      for i = 3 to 0 step -1
        f = t[i][i]

        if f = 0
          ' Cannot invert singular matrix
          return BGE.Math.getFloat44Identity()
        end if

        for j = 0 to 3
          t[i][j] /= f
          s[i][j] /= f
        end for

        for j = 0 to i - 1
          f = t[j][i]

          for k = 0 to 3
            t[j][k] -= f * t[i][k]
            s[j][k] -= f * s[i][k]
          end for
        end for
      end for

      return create(s)
    end function

    ' Set current matrix to its inverse
    sub invert(mat as float[][])
      BGE.Math.fillFloat44(mat, inverse(mat))
    end sub


    function toStr(mat as float[][]) as string
      return `[${rodash.toString(mat[0])},\n ${rodash.toString(mat[1])},\n ${rodash.toString(mat[2])},\n ${rodash.toString(mat[3])}]`
    end function

  end namespace


  function lookAt(from as Vector, lookTo as Vector) as float[][]
    tmp = {x: 0, y: 1, z: 0}
    ' because the forward axis in a right hand coordinate system points backward we compute -(to - from)

    c = BGE.Math.VectorOps.subtract(from, lookTo)
    BGE.Math.VectorOps.normalize(c)
    a = BGE.Math.VectorOps.crossProduct(tmp, c)
    BGE.Math.VectorOps.normalize(a) ' this is just in case Up is not normalized
    b = BGE.Math.VectorOps.crossProduct(c, a)

    camToWorld = BGE.Math.getFloat44Identity()

    ' set x - axis
    camToWorld[0][0] = a.x
    camToWorld[0][1] = a.y
    camToWorld[0][2] = a.z
    ' set y - axis
    camToWorld[1][0] = b.x
    camToWorld[1][1] = b.y
    camToWorld[1][2] = b.z
    ' set z - axis
    camToWorld[2][0] = c.x
    camToWorld[2][1] = c.y
    camToWorld[2][2] = c.z
    ' set position
    camToWorld[3][0] = from.x
    camToWorld[3][1] = from.y
    camToWorld[3][2] = from.z

    return camToWorld
  end function


  function orthographicMatrix(top as float, bottom as float, left as float, right as float, far as float, near as float) as float[][]
    t = top
    l = left
    b = bottom
    r = right
    f = far
    n = near

    ' set OpenGL perspective projection matrix
    return [
      [2 / (r - l), 0, 0, 0],
      [0, 2 / (t - b), 0, 0],
      [0, 0, -2 / (f - n), 0],
      [0 - (r + l) / (r - l), - (t + b) / (t - b), - (f + n) / (f - n), 1]
    ]

    ' this is flipped
    ' set OpenGL perspective projection matrix
    'return [
    '  [2 / (r - l), 0, 0, - (r + l) / (r - l)],
    ' [0, 2 / (t - b), 0, - (t + b) / (t - b)],
    ' [0, 0, -2 / (f - n), - (f + n) / (f - n)],
    ' [0, 0, 0, 1]
    ']
  end function


  function getScaleMatrix(scale as Vector) as float[][]
    dim matrix[3, 3]

    matrix[0][0] = scale.x
    matrix[0][1] = 0
    matrix[0][2] = 0
    matrix[0][3] = 0
    matrix[1][0] = 0
    matrix[1][1] = scale.y
    matrix[1][2] = 0
    matrix[1][3] = 0
    matrix[2][0] = 0
    matrix[2][1] = 0
    matrix[2][2] = scale.z
    matrix[2][3] = 0
    matrix[3][0] = 0
    matrix[3][1] = 0
    matrix[3][2] = 0
    matrix[3][3] = 1

    return matrix
  end function


  function getRotationMatrix(rotation as Vector) as float[][]
    thetaX = rotation.x
    thetaY = rotation.y
    thetaZ = rotation.z
    result = getFloat44Identity()

    'Rotate about the X-Axis
    if thetaX <> 0
      sinX = sin(thetaX)
      cosX = cos(thetaX)

      rotXMatrix = getFloat44Identity()
      rotXMatrix[1][1] = cosX
      rotXMatrix[1][2] = -sinX
      rotXMatrix[2][1] = sinX
      rotXMatrix[2][2] = cosX
      result = BGE.Math.Matrix44.multiply(result, rotXMatrix)
    end if

    'Rotate about the Y - Axis
    if thetaY <> 0
      sinY = sin(thetaY)
      cosY = cos(thetaY)

      rotYMatrix = getFloat44Identity()
      rotYMatrix[0][0] = cosY
      rotYMatrix[0][2] = sinY
      rotYMatrix[2][0] = -sinY
      rotYMatrix[2][2] = cosY

      result = BGE.Math.Matrix44.multiply(result, rotYMatrix)
    end if

    'Rotate about the Z - Axis
    if thetaZ <> 0
      sinZ = sin(thetaZ)
      cosZ = cos(thetaZ)

      rotZMatrix = getFloat44Identity()
      rotZMatrix[0][0] = cosZ
      rotZMatrix[0][1] = sinZ
      rotZMatrix[1][0] = -sinZ
      rotZMatrix[1][1] = cosZ
      result = BGE.Math.Matrix44.multiply(result, rotZMatrix)
    end if

    return result
  end function


  function getTranslationMatrix(position as Vector) as float[][]

    dim matrix[3, 3]

    matrix[0][0] = 1
    matrix[0][1] = 0
    matrix[0][2] = 0
    matrix[0][3] = 0
    matrix[1][0] = 0
    matrix[1][1] = 1
    matrix[1][2] = 0
    matrix[1][3] = 0
    matrix[2][0] = 0
    matrix[2][1] = 0
    matrix[2][2] = 1
    matrix[2][3] = 0
    matrix[3][0] = position.x
    matrix[3][1] = position.y
    matrix[3][2] = position.z
    matrix[3][3] = 1
    return matrix
  end function



  function getTransformationMatrix(position as Vector, rotation as Vector, scale as Vector) as float[][]
    scaleMatrix = getScaleMatrix(scale)

    rotationMatrix = getRotationMatrix(rotation)

    translationMatrix = getTranslationMatrix(position)

    return BGE.Math.Matrix44.multiply(scaleMatrix, BGE.Math.Matrix44.multiply(rotationMatrix, translationMatrix))
  end function

end namespace
