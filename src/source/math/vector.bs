namespace BGE.Math


  class Vector
    public x as float = 0.0
    public y as float = 0.0
    public z as float = 0.0

    sub new(x = 0.0 as float, y = 0.0 as float, z = 0.0 as float)
      m.x = x * 1.0
      m.y = y * 1.0
      m.z = z * 1.0
    end sub

    function getIndex(index as integer) as float
      if index = 0
        return m.x
      else if index = 1
        return m.y
      else if index = 2
        return m.z
      end if
      return invalid
    end function

    function setFrom(b as Vector) as Vector
      m.x = b.x
      m.y = b.y
      m.z = b.z

      return m
    end function

    function add(v as Vector) as Vector
      return new Vector(m.x + v.x, m.y + v.y, m.z + v.z)
    end function

    function equals(v as Vector) as boolean
      return m.x = v.x and m.y = v.y and m.z = v.z
    end function

    sub plusEquals(v as Vector)
      m.x += v.x
      m.y += v.y
      m.z += v.z
    end sub

    function subtract(v as Vector) as Vector
      return new Vector(m.x - v.x, m.y - v.y, m.z - v.z)
    end function

    sub minusEquals(v as Vector)
      m.x -= v.x
      m.y -= v.y
      m.z -= v.z
    end sub

    function negative() as Vector
      return new Vector(-m.x, -m.y, -m.z)
    end function

    function flipX() as Vector
      return new Vector(-m.x, m.y, m.z)
    end function

    function flipY() as Vector
      return new Vector(m.x, -m.y, m.z)
    end function

    function scale(r as float) as Vector
      return new Vector(m.x * r, m.y * r, m.z * r)
    end function

    sub scaleEquals(r as float)
      m.x *= r
      m.y *= r
      m.z *= r
    end sub

    function multiply(v as Vector) as Vector
      return new Vector(m.x * v.x, m.y * v.y, m.z * v.z)
    end function

    sub multEquals(v as Vector)
      m.x *= v.x
      m.y *= v.y
      m.z *= v.z
    end sub

    function dotProduct(v as Vector) as float
      return m.x * v.x + m.y * v.y + m.z * v.z
    end function

    function divide(r as float) as Vector
      return new Vector(m.x / r, m.y / r, m.z / r)
    end function


    ' Makes a copy of this vector
    '
    ' @return {Vector}
    function copy() as Vector
      return new Vector(m.x, m.y, m.z)
    end function

    function crossProduct(v as Vector) as Vector
      return new Vector(m.y * v.z - m.z * v.y, m.z * v.x - m.x * v.z, m.x * v.y - m.y * v.x)
    end function

    ' Gets the square of the length of a vector
    '
    ' @return {float}
    function norm() as float
      return m.x * m.x + m.y * m.y + m.z * m.z
    end function

    ' Gets the length of a vector
    '
    ' @return {float}
    function length() as float
      return sqr(m.norm())
    end function

    ' Gets the manhattan length of a vector
    '
    ' @return {float}
    function manhattanLength() as float
      return abs(m.x) + abs(m.y) + abs(m.z)
    end function

    function normalize() as Vector
      n = m.norm()
      if (n > 0)
        factor = 1 / sqr(n)
        m.x *= factor
        m.y *= factor
        m.z *= factor
      end if

      return m
    end function

    function getNormalizedCopy() as Vector
      return m.copy().normalize()
    end function


    function cint() as Vector
      return new Vector(cint(m.x), cint(m.y), cint(m.z))
    end function

    function toStr() as string
      return `[${m.x} ${m.y} ${m.z}]`
    end function

    function toArray() as float[]
      return [m.x, m.y, m.z]
    end function


    function isParallel(v as Vector) as boolean
      div = 1
      one = m.toArray()
      two = v.toArray()
      if two[0] <> 0
        div = one[0] / two[0]
      else if two[1] <> 0
        div = one[1] / two[1]
      else if two[2] <> 0
        div = one[2] / two[2]
      end if


      for i = 0 to 2
        if one[i] <> div * two[i]:
          return false
        end if
      end for
      return true
    end function


    function isZero() as boolean
      return m.x = 0 and m.y = 0 and m.z = 0
    end function

    function minBound(v as Vector) as Vector
      return new Vector(Min(m.x, v.x), Min(m.y, v.y), Min(m.z, v.z))
    end function

    function maxBound(v as Vector) as Vector
      return new Vector(Max(m.x, v.x), Max(m.y, v.y), Max(m.z, v.z))
    end function

  end class


  function VectorIdentity() as Vector
    return new Vector()
  end function

  function VectorFromFloatArray(array as float[]) as Vector
    if invalid = array or array.Count() < 3
      return invalid
    end if
    return new Vector(array[0], array[1], array[2])
  end function


  ' @param {float} scale_x - horizontal scale
  ' @param {dynamic} [scale_y=invalid] - vertical scale, or if invalid, use the horizontal scale as vertical scale
  function createScaleVector(scale_x as float, scale_y = invalid as dynamic, scale_z = invalid as dynamic) as Vector
    result = VectorIdentity()
    if invalid = scale_y
      scale_y = scale_x
    end if
    if invalid = scale_z
      scale_z = scale_x
    end if
    result.x = scale_x
    result.y = scale_y
    result.z = scale_z
    return result
  end function


  function distanceFromPlane(planePoint as Vector, planeNormal as Vector, targetPoint as Vector) as float
    diff = targetPoint.subtract(planePoint)
    return diff.dotProduct(planeNormal)
  end function

  function midPointBetweenPoints(a as Vector, b as Vector) as Vector
    return a.add(b.subtract(a).divide(2))
  end function


  function getBounds(points as Vector[]) as Vector[]
    if invalid = points or points.count() < 1
      return []
    end if

    minPoint = points[0].copy()
    maxPoint = points[0].copy()

    for i = 1 to points.count() - 1
      p = points[i]
      minPoint.x = min(minPoint.x, p.x)
      minPoint.y = min(minPoint.y, p.y)
      minPoint.z = min(minPoint.z, p.z)
      maxPoint.x = max(maxPoint.x, p.x)
      maxPoint.y = max(maxPoint.y, p.y)
      maxPoint.z = max(maxPoint.z, p.z)
    end for

    return [minPoint, maxPoint]
  end function

  function getBoundingCubePoints(points as Vector[]) as Vector[]
    bounds = getBounds(points)

    if bounds.count() < 2
      return []
    end if
    minP = bounds[0]
    maxP = bounds[1]
    return [
      minP,
      new Vector(minP.x, minP.y, maxP.z),
      new Vector(minP.x, maxP.y, minP.z),
      new Vector(minP.x, maxP.y, maxP.z),
      new Vector(maxP.x, minP.y, minP.z),
      new Vector(maxP.x, minP.y, maxP.z),
      new Vector(maxP.x, maxP.y, minP.z),
      maxP
    ]
  end function

  function vectorArraysEqual(a = [] as Vector[], b = [] as Vector[]) as boolean
    if a.count() <> b.count()
      return false
    end if

    same = true

    for i = 0 to a.count() - 1
      same = a[i].equals(b[i])
      if not same
        exit for
      end if
    end for

    return same
  end function


  function vectorArrayCopy(a = [] as Vector[]) as Vector[]
    out = []

    for i = 0 to a.count() - 1
      out.push(a[i].copy())
    end for

    return out
  end function



  ' From https://paulbourke.net/geometry/pointlineplane/javascript.txt
  '
  '
  ' @param {Vector} p1
  ' @param {Vector} p2
  ' @param {Vector} p3
  ' @param {Vector} p4
  ' @return {Vector}
  function intersectPointPoint(p1 as Vector, p2 as Vector, p3 as Vector, p4 as Vector, mustBeInSegment = false) as Vector
    x1 = p1.x
    y1 = p1.y
    x2 = p2.x
    y2 = p2.y
    x3 = p3.x
    y3 = p3.y
    x4 = p4.x
    y4 = p4.y

    ' Check if none of the lines are of length 0
    if (x1 = x2 and y1 = y2) or (x3 = x4 and y3 = y4)
      return invalid
    end if

    denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1))

    ' Lines are parallel
    if (denominator = 0)
      return invalid
    end if

    ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator
    ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator

    ' is the intersection along the segments
    if mustBeInSegment and (ua < 0 or ua > 1 or ub < 0 or ub > 1)
      return invalid
    end if

    ' Return a object with the x and y coordinates of the intersection
    x = x1 + ua * (x2 - x1)
    y = y1 + ua * (y2 - y1)

    return new Vector(x, y)
  end function


  function intersectPointAngle(p1 as Vector, angle1FromXAxis as float, p2 as Vector, angle2FromXAxis as float) as Vector
    p1a = new BGE.Math.Vector(p1.x + 100 * cos(angle1FromXAxis), p1.y + 100 * sin(angle1FromXAxis))
    p2a = new BGE.Math.Vector(p2.x - 100 * cos(angle2FromXAxis), p2.y - 100 * sin(angle2FromXAxis))

    return intersectPointPoint(p1, p1a, p2, p2a)
  end function

end namespace
