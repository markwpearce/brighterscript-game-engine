namespace BGE.Math


  class Vector
    public x as float = 0.0
    public y as float = 0.0
    public z as float = 0.0

    sub new(x = 0.0 as float, y = 0.0 as float, z = 0.0 as float)
      m.x = x * 1.0
      m.y = y * 1.0
      m.z = z * 1.0
    end sub

    function getIndex(index as integer) as float
      if index = 0
        return m.x
      else if index = 1
        return m.y
      else if index = 2
        return m.z
      end if
      return invalid
    end function

    function setFrom(b as Vector) as Vector
      m.x = b.x
      m.y = b.y
      m.z = b.z

      return m
    end function

    function add(v as Vector) as Vector
      return new Vector(m.x + v.x, m.y + v.y, m.z + v.z)
    end function

    function equals(v as Vector) as boolean
      return m.x = v.x and m.y = v.y and m.z = v.z
    end function

    sub plusEquals(v as Vector)
      m.x += v.x
      m.y += v.y
      m.z += v.z
    end sub

    function subtract(v as Vector) as Vector
      return new Vector(m.x - v.x, m.y - v.y, m.z - v.z)
    end function

    sub minusEquals(v as Vector)
      m.x -= v.x
      m.y -= v.y
      m.z -= v.z
    end sub

    function negative() as Vector
      return new Vector(-m.x, -m.y, -m.z)
    end function

    function flipX() as Vector
      return new Vector(-m.x, m.y, m.z)
    end function

    function flipY() as Vector
      return new Vector(m.x, -m.y, m.z)
    end function

    function scale(r as float) as Vector
      return new Vector(m.x * r, m.y * r, m.z * r)
    end function

    sub scaleEquals(r as float)
      m.x *= r
      m.y *= r
      m.z *= r
    end sub

    function multiply(v as Vector) as Vector
      return new Vector(m.x * v.x, m.y * v.y, m.z * v.z)
    end function

    sub multEquals(v as Vector)
      m.x *= v.x
      m.y *= v.y
      m.z *= v.z
    end sub

    function dotProduct(v as Vector) as float
      return m.x * v.x + m.y * v.y + m.z * v.z
    end function

    function divide(r as float) as Vector
      return new Vector(m.x / r, m.y / r, m.z / r)
    end function


    ' Makes a copy of this vector
    '
    ' @return {Vector}
    function copy() as Vector
      return new Vector(m.x, m.y, m.z)
    end function

    function crossProduct(v as Vector) as Vector
      return new Vector(m.y * v.z - m.z * v.y, m.z * v.x - m.x * v.z, m.x * v.y - m.y * v.x)
    end function

    ' Gets the square of the length of a vector
    '
    ' @return {float}
    function norm() as float
      return m.x * m.x + m.y * m.y + m.z * m.z
    end function

    ' Gets the length of a vector
    '
    ' @return {float}
    function length() as float
      return sqr(m.norm())
    end function

    function normalize() as Vector
      n = m.norm()
      if (n > 0)
        factor = 1 / sqr(n)
        m.x *= factor
        m.y *= factor
        m.z *= factor
      end if

      return m
    end function

    function getNormalizedCopy() as Vector
      return m.copy().normalize()
    end function


    function cint() as Vector
      return new Vector(cint(m.x), cint(m.y), cint(m.z))
    end function

    function toStr() as string
      return `[${m.x} ${m.y} ${m.z}]`
    end function

    function toArray() as float[]
      return [m.x, m.y, m.z]
    end function


    function isParallel(v as Vector) as boolean
      div = 1
      one = m.toArray()
      two = v.toArray()
      if two[0] <> 0
        div = one[0] / two[0]
      else if two[1] <> 0
        div = one[1] / two[1]
      else if two[2] <> 0
        div = one[2] / two[2]
      end if


      for i = 0 to 2
        if one[i] <> div * two[i]:
          return false
        end if
      end for
      return true
    end function


    function isZero() as boolean
      return m.x = 0 and m.y = 0 and m.z = 0
    end function

  end class


  function VectorIdentity() as Vector
    return new Vector()
  end function


  ' @param {float} scale_x - horizontal scale
  ' @param {dynamic} [scale_y=invalid] - vertical scale, or if invalid, use the horizontal scale as vertical scale
  function createScaleVector(scale_x as float, scale_y = invalid as dynamic, scale_z = invalid as dynamic) as Vector
    result = VectorIdentity()
    if invalid = scale_y
      scale_y = scale_x
    end if
    if invalid = scale_z
      scale_z = scale_x
    end if
    result.x = scale_x
    result.y = scale_y
    result.z = scale_z
    return result
  end function


  function distanceFromPlane(planePoint as Vector, planeNormal as Vector, targetPoint as Vector) as float
    diff = targetPoint.subtract(planePoint)
    return diff.dotProduct(planeNormal)
  end function




  function midPointBetweenPoints(a as Vector, b as Vector) as Vector
    return a.add(b.subtract(a).divide(2))
  end function


  function getBounds(points as Vector[]) as Vector[]
    if invalid = points or points.count() < 1
      return []
    end if

    minPoint = points[0].copy()
    maxPoint = points[0].copy()

    for i = 1 to points.count() - 1
      p = points[i]
      minPoint.x = min(minPoint.x, p.x)
      minPoint.y = min(minPoint.y, p.y)
      minPoint.z = min(minPoint.z, p.z)
      maxPoint.x = max(maxPoint.x, p.x)
      maxPoint.y = max(maxPoint.y, p.y)
      maxPoint.z = max(maxPoint.z, p.z)
    end for

    return [minPoint, maxPoint]
  end function

  function getBoundingCubePoints(points as Vector[]) as Vector[]
    bounds = getBounds(points)

    if bounds.count() < 2
      return []
    end if
    minP = bounds[0]
    maxP = bounds[1]
    return [
      minP,
      new Vector(minP.x, minP.y, maxP.z),
      new Vector(minP.x, maxP.y, minP.z),
      new Vector(minP.x, maxP.y, maxP.z),
      new Vector(maxP.x, minP.y, minP.z),
      new Vector(maxP.x, minP.y, maxP.z),
      new Vector(maxP.x, maxP.y, minP.z),
      maxP
    ]
  end function

  function vectorArraysEqual(a = [] as Vector[], b = [] as Vector[]) as Vector[]
    if a.count() <> b.count()
      return false
    end if

    same = true

    for i = 0 to a.count() - 1
      same = a[i].equals(b[i])
      if not same
        exit for
      end if
    end for

    return same
  end function


  function vectorArrayCopy(a = [] as Vector[]) as Vector[]
    out = []

    for i = 0 to a.count() - 1
      out.push(a[i].copy())
    end for

    return out
  end function

end namespace
