namespace BGE.Math


  interface Vector
    x as float
    y as float
    optional z as float
  end interface

  namespace VectorOps
    function create(x = 0.0 as float, y = 0.0 as float, z = 0.0 as dynamic) as Vector
      if z = invalid
        z = 0
      end if
      return {
        x: x * 1.0
        y: y * 1.0
        z: z * 1.0
      }
    end function

    function setFrom(a as Vector, b as Vector) as Vector
      a.x = b.x
      a.y = b.y
      a.z = b.z

      return a
    end function

    function add(a as Vector, b as Vector) as Vector
      return {x: a.x + b.x, y: a.y + b.y, z: a.z + b.z}
    end function

    function equals(a as Vector, b as Vector) as boolean
      return a.x = b.x and a.y = b.y and a.z = b.z
    end function

    sub plusEquals(a as Vector, v as Vector)
      a.x += v.x
      a.y += v.y
      a.z += v.z
    end sub

    function subtract(a as Vector, v as Vector) as Vector
      return {x: a.x - v.x, y: a.y - v.y, z: a.z - v.z}
    end function

    sub minusEquals(a as Vector, v as Vector)
      a.x -= v.x
      a.y -= v.y
      a.z -= v.z
    end sub

    function negative(a as Vector) as Vector
      return {x: -a.x, y: -a.y, z: -a.z}
    end function

    function flipX(a as Vector) as Vector
      return {x: -a.x, y: a.y, z: a.z}
    end function

    function flipY(a as Vector) as Vector
      return {x: a.x, y: -a.y, z: a.z}
    end function

    function scale(v as Vector, r as float) as Vector
      return {x: v.x * r, y: v.y * r, z: v.z * r}
    end function

    sub scaleEquals(v as Vector, r as float)
      v.x *= r
      v.y *= r
      v.z *= r
    end sub

    function multiply(a as Vector, v as Vector) as Vector
      return {x: a.x * v.x, y: a.y * v.y, z: a.z * v.z}
    end function

    sub multEquals(a as Vector, v as Vector)
      a.x *= v.x
      a.y *= v.y
      a.z *= v.z
    end sub

    function dotProduct(a as Vector, v as Vector) as float
      return a.x * v.x + a.y * v.y + a.z * v.z
    end function

    function divide(a as Vector, r as float) as Vector
      return {x: a.x / r, y: a.y / r, z: a.z / r}
    end function


    ' Makes a copy of this vector
    '
    ' @return {Vector}
    function copy(v as Vector) as Vector
      return {x: v.x, y: v.y, z: v.z}
    end function

    function crossProduct(a as Vector, v as Vector) as Vector
      return {
        x: a.y * v.z - a.z * v.y,
        y: a.z * v.x - a.x * v.z,
        z: a.x * v.y - a.y * v.x
      }
    end function

    ' Gets the square of the length of a vector
    '
    ' @return {float}
    function norm(v as Vector) as float
      return v.x * v.x + v.y * v.y + v.z * v.z
    end function

    ' Gets the length of a vector
    '
    ' @return {float}
    function length(v as Vector) as float
      return sqr(norm(v))
    end function

    ' Gets the manhattan length of a vector
    '
    ' @return {float}
    function manhattanLength(v as Vector) as float
      return abs(v.x) + abs(v.y) + abs(v.z)
    end function

    sub normalize(v as Vector)
      n = norm(v)
      if (n > 0)
        factor = 1 / sqr(n)
        v.x *= factor
        v.y *= factor
        v.z *= factor
      end if
    end sub

    function getNormalizedCopy(v as Vector) as Vector
      normalize(copy(v))
      return v
    end function


    function nearestInt(v as Vector) as Vector
      return {x: cint(v.x), y: cint(v.y), z: cint(v.z)}
    end function

    function toStr(v as Vector) as string
      return `[${v.x} ${v.y} ${v.z}]`
    end function

    function toArray(v as Vector) as float[]
      return [v.x, v.y, v.z]
    end function


    function isParallel(a as Vector, v as Vector) as boolean
      div = 1
      one = toArray(a)
      two = toArray(v)
      if two[0] <> 0
        div = one[0] / two[0]
      else if two[1] <> 0
        div = one[1] / two[1]
      else if two[2] <> 0
        div = one[2] / two[2]
      end if


      for i = 0 to 2
        if one[i] <> div * two[i]:
          return false
        end if
      end for
      return true
    end function


    function isZero(v as Vector) as boolean
      return v.x = 0 and v.y = 0 and v.z = 0
    end function

    function minBound(a as Vector, v as Vector) as Vector
      return {x: BGE.Math.Min(a.x, v.x), y: BGE.Math.Min(a.y, v.y), z: BGE.Math.Min(a.z, v.z)}
    end function

    function maxBound(a as Vector, v as Vector) as Vector
      return {x: BGE.Math.Max(a.x, v.x), y: BGE.Math.Max(a.y, v.y), z: BGE.Math.Max(a.z, v.z)}
    end function
  end namespace

  function VectorZero() as Vector
    return BGE.Math.VectorOps.create()
  end function

  function VectorFromFloatArray(array as float[]) as Vector
    if invalid = array or array.Count() < 3
      return invalid
    end if
    return {x: array[0], y: array[1], z: array[2]}
  end function


  ' @param {float} scale_x - horizontal scale
  ' @param {dynamic} [scale_y=invalid] - vertical scale, or if invalid, use the horizontal scale as vertical scale
  function createScaleVector(scale_x as float, scale_y = invalid as dynamic, scale_z = invalid as dynamic) as Vector
    result = BGE.MATH.VectorOps.create()
    if invalid = scale_y
      scale_y = scale_x
    end if
    if invalid = scale_z
      scale_z = scale_x
    end if
    result.x = scale_x
    result.y = scale_y
    result.z = scale_z
    return result
  end function


  function distanceFromPlane(planePoint as Vector, planeNormal as Vector, targetPoint as Vector) as float
    diff = BGE.Math.VectorOps.subtract(targetPoint, planePoint)
    return BGE.Math.VectorOps.dotProduct(diff, planeNormal)
  end function

  function midPointBetweenPoints(a as Vector, b as Vector) as Vector
    return {
      x: (a.x + b.x) / 2,
      y: (a.y + b.y) / 2,
      z: (a.z + b.z) / 2,
    }
  end function


  function getBounds(points as Vector[]) as Vector[]
    if invalid = points or points.count() < 1
      return []
    end if

    minPoint = BGE.Math.VectorOps.create(points[0].x, points[0].y, points[0].z)
    maxPoint = BGE.Math.VectorOps.create(points[0].x, points[0].y, points[0].z)

    for i = 1 to points.count() - 1
      p = points[i]
      minPoint.x = min(minPoint.x, p.x)
      minPoint.y = min(minPoint.y, p.y)
      if p.z <> invalid
        minPoint.z = min(minPoint.z, p.z)
      end if
      maxPoint.x = max(maxPoint.x, p.x)
      maxPoint.y = max(maxPoint.y, p.y)
      if p.z <> invalid
        maxPoint.z = max(maxPoint.z, p.z)
      end if
    end for

    return [minPoint, maxPoint]
  end function

  function getBoundingCubePoints(points as Vector[]) as Vector[]
    bounds = getBounds(points)

    if bounds.count() < 2
      return []
    end if
    minP = bounds[0]
    maxP = bounds[1]
    return [
      minP,
      {x: minP.x, y: minP.y, z: maxP.z},
      {x: minP.x, y: maxP.y, z: minP.z},
      {x: minP.x, y: maxP.y, z: maxP.z},
      {x: maxP.x, y: minP.y, z: minP.z},
      {x: maxP.x, y: minP.y, z: maxP.z},
      {x: maxP.x, y: maxP.y, z: minP.z},
      maxP
    ]
  end function

  function vectorArraysEqual(a = [] as Vector[], b = [] as Vector[]) as boolean
    if a.count() <> b.count()
      return false
    end if

    same = true

    for i = 0 to a.count() - 1
      same = BGE.Math.VectorOps.equals(a[i], b[i])
      if not same
        exit for
      end if
    end for

    return same
  end function


  function vectorArrayCopy(a = [] as Vector[]) as Vector[]
    out = []

    for i = 0 to a.count() - 1
      out.push(BGE.Math.VectorOps.copy(a[i]))
    end for

    return out
  end function



  ' From https://paulbourke.net/geometry/pointlineplane/javascript.txt
  '
  '
  ' @param {Vector} p1
  ' @param {Vector} p2
  ' @param {Vector} p3
  ' @param {Vector} p4
  ' @return {Vector}
  function intersectPointPoint(p1 as Vector, p2 as Vector, p3 as Vector, p4 as Vector, mustBeInSegment = false) as Vector
    x1 = p1.x
    y1 = p1.y
    x2 = p2.x
    y2 = p2.y
    x3 = p3.x
    y3 = p3.y
    x4 = p4.x
    y4 = p4.y

    ' Check if none of the lines are of length 0
    if (x1 = x2 and y1 = y2) or (x3 = x4 and y3 = y4)
      return invalid
    end if

    denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1))

    ' Lines are parallel
    if (denominator = 0)
      return invalid
    end if

    ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator
    ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator

    ' is the intersection along the segments
    if mustBeInSegment and (ua < 0 or ua > 1 or ub < 0 or ub > 1)
      return invalid
    end if

    ' Return a object with the x and y coordinates of the intersection
    x = x1 + ua * (x2 - x1)
    y = y1 + ua * (y2 - y1)

    return {x: x, y: y, z: 0}
  end function


  function intersectPointAngle(p1 as Vector, angle1FromXAxis as float, p2 as Vector, angle2FromXAxis as float) as Vector
    p1a = {x: p1.x + 100 * cos(angle1FromXAxis), y: p1.y + 100 * sin(angle1FromXAxis), z: 0}
    p2a = {x: p2.x - 100 * cos(angle2FromXAxis), y: p2.y - 100 * sin(angle2FromXAxis), z: 0}

    return intersectPointPoint(p1, p1a, p2, p2a)
  end function

end namespace
