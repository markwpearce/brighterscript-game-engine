namespace BGE

  enum CameraFrustumSide
    top = "top"
    bottom = "bottom"
    left = "left"
    right = "right"
    near = "near"
  end enum


  class CameraFrustumNormals
    top as BGE.Math.Vector
    bottom as BGE.Math.Vector
    left as BGE.Math.Vector
    right as BGE.Math.Vector
    near as BGE.Math.Vector


    sub setNormals(cameraOrientation as BGE.Math.Vector, fovDegrees as float)
      'near
      m.near = cameraOrientation.copy()

      fovRad = BGE.Math.DegreesToRadians(fovDegrees)
      rotVect = new BGE.Math.Vector()

      'top
      rotVect.x = fovRad / 2
      rotVect.y = 0
      m.top = BGE.Math.getRotationMatrix(rotVect).multDirMatrix(cameraOrientation)

      'bottom
      rotVect.x = -fovRad / 2
      rotVect.y = 0
      m.bottom = BGE.Math.getRotationMatrix(rotVect).multDirMatrix(cameraOrientation)

      'left
      rotVect.x = 0
      rotVect.y = fovRad / 2
      m.left = BGE.Math.getRotationMatrix(rotVect).multDirMatrix(cameraOrientation)

      'right
      rotVect.x = 0
      rotVect.y = -fovRad / 2
      m.right = BGE.Math.getRotationMatrix(rotVect).multDirMatrix(cameraOrientation)


      ?"New FrustumNormals:"
      ?"near: ";m.near.toStr()
      ?"top: ";m.top.toStr()
      ?"bottom: ";m.bottom.toStr()
      ?"left: ";m.left.toStr()
      ?"right: ";m.right.toStr()
    end sub

  end class

  class Camera

    orientation as BGE.Math.Vector = new BGE.Math.Vector(0, 0, 1)

    position as BGE.Math.Vector = new BGE.Math.Vector(0, 0, -1000)

    motionChecker as MotionChecker = new MotionChecker()

    viewFrustumWidened = false

    viewFrustumThreshold = BGE.Math.DegreesToRadians(1)

    fieldOfViewDegrees as float = 90

    protected frustumNormals as CameraFrustumNormals = new CameraFrustumNormals()

    sub setTarget(targetPos as BGE.Math.Vector)
      m.orientation = targetPos.subtract(m.position).normalize()
    end sub


    sub rotate(rotation as BGE.Math.Vector)
      m.orientation = BGE.Math.getRotationMatrix(rotation).multVecMatrix(m.orientation)
    end sub

    sub checkMovement()
      currentlyMoved = m.motionChecker.check(m.position, m.orientation)
      if m.movedLastFrame() and not currentlyMoved
        m.motionChecker.resetMovedFlag()
        return
      end if

      if currentlyMoved
        m.frustumNormals.setNormals(m.orientation, m.fieldOfViewDegrees)
        rotationDifference = m.motionChecker.getRotationDifference(m.orientation).norm()

        m.viewFrustumWidened = rotationDifference > m.viewFrustumThreshold
        if rotationDifference = 0
          ' Camera didn't rotate, but if it moved backwards, the view frustum might have widened
          positionDifference = m.motionChecker.getPositionDifference(m.position)
          m.viewFrustumWidened = not positionDifference.isParallel(m.orientation)
        end if

        m.motionChecker.setTransform(m.position, m.orientation)
      end if
    end sub

    function movedLastFrame() as boolean
      return m.motionChecker.movedLastFrame
    end function

    function didViewFrustumWidenLastFrame() as boolean
      return m.viewFrustumWidened
    end function

    function distanceFromFrustum(frustumSide as string, point as BGE.Math.Vector) as float
      frusNorm = m.frustumNormals[frustumSide]
      return BGE.Math.distanceFromPlane(m.position, frusNorm, point)
    end function



    function isInFrustum(point as BGE.Math.Vector) as boolean
      frustumSides = ["near", "top", "left", "right", "bottom"]

      for each side in frustumSides
        distance = m.distanceFromFrustum(side, point)
        if distance < 0
          ?"Not in frustum ";side; m.frustumNormals[side].toStr();" - "; point.toStr()
          return false

        end if
      end for
      return true
    end function

  end class


end namespace