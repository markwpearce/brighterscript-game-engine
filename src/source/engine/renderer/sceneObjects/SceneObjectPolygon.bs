namespace BGE

  class SceneObjectPolygon extends SceneObjectBillboard

    drawable as DrawablePolygon

    private lastPolygonPoints as BGE.Math.Vector[] = []
    private polygonCanvasPoints as BGE.Math.Vector[] = []
    private polygonWorldPoints as BGE.Math.Vector[] = []

    sub new(name as string, drawableObj as DrawablePolygon)
      super(name, drawableObj, "Polygon" as SceneObjectType)
      m.useTempBitmapMap[BGE.SceneObjectDrawMode.matchCamera] = true
      m.useTempBitmapMap[BGE.SceneObjectDrawMode.directToCamera] = true
      m.useTempBitmapMap[BGE.SceneObjectDrawMode.oriented] = true
      m.useTempBitmapMap[SceneObjectDrawMode.orientedDrawBackFace] = true
      m.useTempBitmapMap[SceneObjectDrawMode.wireFrame] = true
      m.useTempBitmapMap[SceneObjectDrawMode.wireFrameDrawBackFace] = true
    end sub

    protected override function didRegionToDrawChange() as boolean
      return not BGE.Math.vectorArraysEqual(m.lastPolygonPoints, m.drawable.points)
    end function


    protected override function drawToCanvas(rendererObj as BGE.Renderer, drawMode as SceneObjectDrawMode) as boolean
      return rendererObj.drawPolygon(m.polygonCanvasPoints, 0, 0, m.drawable.getFillColorRGBA())
    end function

    protected override function getAllCanvasPoints() as BGE.Math.Vector[]
      return m.polygonCanvasPoints
    end function

    protected override function drawToTempBitmap(rendererObj as BGE.Renderer, tempBitmap as ifDraw2d, canvasPointsTopLeftBound as BGE.Math.Vector, drawMode as SceneObjectDrawMode) as boolean
      if tempBitmap = invalid
        return false
      end if
      offsetCanvasPoints = []
      for each point in m.polygonCanvasPoints
        offsetP = BGE.Math.VectorOps.subtract(point, canvasPointsTopLeftBound)
        if invalid <> offsetP
          offsetCanvasPoints.push(offsetP)
        end if
      end for

      tempBmpDidDraw = rendererObj.drawPolygonTo(tempBitmap, offsetCanvasPoints, 0, 0, m.drawable.getFillColorRGBA())
      return tempBmpDidDraw
    end function


    protected override function updateWorldPosition(drawMode as SceneObjectDrawMode) as boolean
      m.polygonWorldPoints = []
      m.worldPosition = m.drawable.getWorldPosition()
      for each point in m.drawable.points
        worldPoint = BGE.Math.Matrix44.multVecMatrix(point, m.transformationMatrix)
        if invalid <> worldPoint
          m.polygonWorldPoints.push(worldPoint)
        end if

      end for

      return m.polygonWorldPoints.Count() > 3
    end function


    override function getPositionForCameraDistance(drawMode as SceneObjectDrawMode) as BGE.Math.Vector
      if drawMode = BGE.SceneObjectDrawMode.oriented
        return m.worldPoints.getCenter()
      end if
      return m.worldPosition
    end function

    override function getPositionsForFrustumCheck(drawMode as SceneObjectDrawMode) as BGE.Math.Vector[]
      'TODO: this is probably too slow - this gives 8 points and needs to loop through all points
      return BGE.Math.getBoundingCubePoints(m.polygonWorldPoints)
    end function

    protected override sub afterDraw()
      m.lastPolygonPoints = BGE.Math.vectorArrayCopy(m.drawable.points)
    end sub

    protected override function updateCanvasPosition(rendererObj as Renderer, drawMode as SceneObjectDrawMode) as boolean
      m.polygonCanvasPoints = []
      for each point in m.polygonWorldPoints
        canvasPoint = rendererObj.worldPointToCanvasPoint(point)
        if invalid <> canvasPoint
          m.polygonCanvasPoints.push(canvasPoint)
        end if
      end for
      return true
    end function

  end class

end namespace