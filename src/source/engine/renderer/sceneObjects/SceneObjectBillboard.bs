namespace BGE

  class SceneObjectBillboard extends SceneObject


    private worldPoints as BGE.Math.CornerPoints = new BGE.Math.CornerPoints()
    private canvasPoints as BGE.Math.CornerPoints = new BGE.Math.CornerPoints()


    private canvasPosition as BGE.Math.Vector

    private isMirror = false

    private surfaceToCameraDotProduct as float
    private surfaceNormal as BGE.Math.Vector
    private normalOnCanvasStart as BGE.Math.Vector
    private normalOnCanvasEnd as BGE.Math.Vector

    private tempBitmap as ifDraw2d = invalid

    protected useTempBitmapMap as boolean[] = [false, false, false]

    sub new(name as string, drawableObj as Drawable, objType as SceneObjectType)
      super(name, drawableObj, objType)
      m.useTempBitmapMap[SceneObjectDrawMode.matchCamera] = false
      m.useTempBitmapMap[SceneObjectDrawMode.directToCamera] = false
      m.useTempBitmapMap[SceneObjectDrawMode.attemptToOrient] = true
    end sub

    protected override function performDraw(rendererObj as BGE.Renderer, drawMode as SceneObjectDrawMode) as boolean
      retVal = false

      if m.isRedrawToCanvasRequired(rendererObj, drawMode)
        ' either this moved recently, changed or not supposed to use temp bitmap in this drawMode
        m.tempBitmap = invalid
        retVal = m.drawToCanvas(rendererObj, drawMode)
      else
        ' nothing changed since last frame, draw a static image that can be used later
        canvasBounds = m.getCanvasBounds()
        if invalid = m.tempBitmap
          canvasBounds = m.getCanvasBounds()
          if invalid = canvasBounds or canvasBounds.count() < 2
            return false
          end if
          canvasSize = canvasBounds[1].subtract(canvasBounds[0])
          m.tempBitmap = createObject("roBitmap", {width: canvasSize.x + 1, height: canvasSize.y + 1, alphaEnable: true})
          tempBitmapDrawn = m.drawToTempBitmap(rendererObj, m.tempBitmap, canvasBounds[0], drawMode)
          if not tempBitmapDrawn
            return false
          end if
        end if
        retVal = rendererObj.drawObject(canvasBounds[0].x, canvasBounds[0].y, m.tempBitmap)
      end if

      if drawMode = BGE.SceneObjectDrawMode.attemptToOrient and invalid <> m.normalOnCanvasStart and invalid <> m.normalOnCanvasEnd
        rendererObj.drawLine(m.normalOnCanvasStart.x, m.normalOnCanvasStart.y, m.normalOnCanvasEnd.x, m.normalOnCanvasEnd.y, BGE.Colors().Pink)
      end if

      return retVal
    end function

    protected function isRedrawToCanvasRequired(rendererObj as BGE.Renderer, drawMode as SceneObjectDrawMode) as boolean
      return not m.useTempBitmapMap[drawMode] or m.objMovedInRelationToCamera(rendererObj.camera) or m.didRegionToDrawChange()
    end function

    protected function drawToCanvas(rendererObj as BGE.Renderer, drawMode as SceneObjectDrawMode) as boolean
      regionToDraw = m.getRegionWithIdToDraw()
      regionObj = regionToDraw.region
      if invalid = regionToDraw or invalid = regionObj
        return false
      end if
      if drawMode = BGE.SceneObjectDrawMode.directToCamera
        drawPos = m.canvasPosition
        totalScaleX = 1.0 * m.drawable.scale.x * m.drawable.owner.scale.x
        totalScaleY = 1.0 * m.drawable.scale.y * m.drawable.owner.scale.y
        theta = m.drawable.rotation.z + m.drawable.owner.rotation.z

        retVal = rendererObj.drawRegion(regionToDraw.region, drawPos.x, drawPos.y, totalScaleX, totalScaleY, -theta)
      else if drawMode = BGE.SceneObjectDrawMode.attemptToOrient
        retVal = rendererObj.drawPinnedCorners(m.canvasPoints, regionToDraw, m.isMirror, m.drawable.getFillColorRGBA())
      end if
      return retVal
    end function

    protected function getCanvasBounds() as BGE.Math.Vector[]
      return m.canvasPoints.getBounds()
    end function

    protected function getRegionWithIdToDraw() as RegionWithId
      return invalid
    end function

    protected function drawToTempBitmap(rendererObj as BGE.Renderer, tempBitmap as ifDraw2d, canvasPointsTopLeftBound as BGE.Math.Vector, drawMode as SceneObjectDrawMode) as boolean
      if invalid = tempBitmap
        return false
      end if

      regionToDraw = m.getRegionWithIdToDraw()
      if invalid = regionToDraw or invalid = regionToDraw.region
        return false
      end if
      regionObj = regionToDraw.region
      preTransX = regionObj.getPretranslationX()
      preTransY = regionObj.getPretranslationY()
      offsetCanvasPoints = m.canvasPoints.subtract(canvasPointsTopLeftBound)
      regionObj.setPretranslation(0, 0)
      tempBmpDidDraw = rendererObj.drawPinnedCornersTo(tempBitmap, offsetCanvasPoints, regionToDraw, m.isMirror, m.drawable.getFillColorRGBA())
      regionObj.setPretranslation(preTransX, preTransY)
      return tempBmpDidDraw
    end function


    protected function didRegionToDrawChange() as boolean
      return false
    end function

    protected override function updateWorldPosition(drawMode as SceneObjectDrawMode) as boolean
      if drawMode = BGE.SceneObjectDrawMode.directToCamera
        m.worldPosition = m.drawable.getWorldPosition()

      else if drawMode = BGE.SceneObjectDrawMode.attemptToOrient
        origin = new BGE.Math.Vector()
        totalScaleX = 1 * m.drawable.scale.x
        totalScaleY = 1 * m.drawable.scale.y
        scaledSize = m.drawable.getDrawnSize()
        scaledWidth = scaledSize.width
        scaledHeight = scaledSize.height
        pretrans = m.drawable.getPretranslation()
        topLeft = new BGE.Math.Vector(pretrans.x * totalScaleX, -pretrans.y * totalScaleY, 0)
        topRight = topLeft.add(new BGE.Math.Vector(scaledWidth, 0, 0))
        bottomLeft = topLeft.add(new BGE.Math.Vector(0, -scaledHeight, 0))
        bottomRight = topLeft.add(new BGE.Math.Vector(scaledWidth, -scaledHeight, 0))

        m.worldPoints.topLeft = m.transformationMatrix.multVecMatrix(topLeft)
        m.worldPoints.topRight = m.transformationMatrix.multVecMatrix(topRight)
        m.worldPoints.bottomLeft = m.transformationMatrix.multVecMatrix(bottomLeft)
        m.worldPoints.bottomRight = m.transformationMatrix.multVecMatrix(bottomRight)
        m.worldPosition = m.worldPoints.topLeft

        m.surfaceNormal = m.worldPoints.getNormal()
      end if
      return true
    end function


    override function getPositionForCameraDistance(drawMode as SceneObjectDrawMode) as BGE.Math.Vector
      if drawMode = BGE.SceneObjectDrawMode.attemptToOrient
        return m.worldPoints.getCenter()
      end if
      return m.worldPosition
    end function

    override function getPositionsForFrustumCheck(drawMode as SceneObjectDrawMode) as BGE.Math.Vector[]
      if drawMode = BGE.SceneObjectDrawMode.attemptToOrient
        return m.worldPoints.toArray()
      end if
      return [m.worldPosition]
    end function

    protected override function findCanvasPosition(rendererObj as Renderer, drawMode as SceneObjectDrawMode) as boolean

      result = m.updateCanvasPosition(rendererObj, drawMode)
      if result and drawMode = BGE.SceneObjectDrawMode.attemptToOrient
        m.computeNormalDebugInfo(rendererObj)
        m.isMirror = false
        if invalid <> m.surfaceNormal
          m.surfaceToCameraDotProduct = m.surfaceNormal.dotProduct(rendererObj.camera.orientation)
          if m.surfaceToCameraDotProduct < 0
            m.isMirror = true
          end if
        end if
      end if
      return result
    end function


    protected function updateCanvasPosition(rendererObj as Renderer, drawMode as SceneObjectDrawMode) as boolean
      if drawMode = BGE.SceneObjectDrawMode.directToCamera
        m.canvasPosition = rendererObj.worldPointToCanvasPoint(m.worldPosition)
        if invalid = m.canvasPosition
          return false
        end if
      else if drawMode = BGE.SceneObjectDrawMode.attemptToOrient
        index = 0
        for each corner in m.worldPoints.toArray()
          canvasPoint = rendererObj.worldPointToCanvasPoint(corner)
          if invalid = canvasPoint
            return false
          end if
          m.canvasPoints.setPointByIndex(index, canvasPoint)
          index++
        end for
      end if
      return true
    end function


    protected sub computeNormalDebugInfo(rendererObj as Renderer)
      if isTrue(m.drawable.owner.game.getDebugValue("draw_scene_object_normals")) and invalid <> m.surfaceNormal and invalid <> m.worldPoints
        normalCenter = m.getNormalDebugPoint()
        m.normalOnCanvasStart = rendererObj.worldPointToCanvasPoint(m.worldPoints.getCenter())
        m.normalOnCanvasEnd = rendererObj.worldPointToCanvasPoint(m.worldPoints.getCenter().subtract(m.surfaceNormal.scale(100)))
      else
        m.normalOnCanvasStart = invalid
        m.normalOnCanvasEnd = invalid
      end if
    end sub

    protected function getNormalDebugPoint() as BGE.Math.Vector
      return m.worldPoints.getCenter()
    end function


  end class

end namespace