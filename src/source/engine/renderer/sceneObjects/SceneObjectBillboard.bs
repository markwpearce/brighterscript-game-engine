namespace BGE

  interface TransformTempBitmapDetails
    origin as BGE.Math.Vector
    rotation as float
    scaleX as float
    scaleY as float
  end interface

  class SceneObjectBillboard extends SceneObject


    private worldPoints as BGE.Math.CornerPoints = new BGE.Math.CornerPoints()
    private canvasPoints as BGE.Math.CornerPoints = new BGE.Math.CornerPoints()

    private canvasPosition as BGE.Math.Vector

    private isMirror = false

    private surfaceToCameraDotProduct as float
    private surfaceNormal as BGE.Math.Vector
    private normalOnCanvasStart as BGE.Math.Vector
    private normalOnCanvasEnd as BGE.Math.Vector

    private tempBitmap as ifDraw2d = invalid

    private limitPointMap as LimitPointMappings = invalid

    protected useTempBitmapMap as boolean[] = [false, false, false, false]

    private hasAccurateTempBitmap = false

    sub new(name as string, drawableObj as Drawable, objType as SceneObjectType)
      super(name, drawableObj, objType)
      m.useTempBitmapMap[SceneObjectDrawMode.matchCamera] = false
      m.useTempBitmapMap[SceneObjectDrawMode.directToCamera] = false
      m.useTempBitmapMap[SceneObjectDrawMode.oriented] = true
      m.useTempBitmapMap[SceneObjectDrawMode.orientedDrawBackFace] = true
      m.useTempBitmapMap[SceneObjectDrawMode.wireFrame] = true
      m.useTempBitmapMap[SceneObjectDrawMode.wireFrameDrawBackFace] = true
    end sub

    protected override function performDraw(rendererObj as BGE.Renderer, drawMode as SceneObjectDrawMode) as boolean
      retVal = false
      canvasBounds = m.getCanvasBounds()
      if m.doNotDrawBecauseBackface(drawMode)
        ' this is backface, and should not be drawn
        m.tempBitmap = invalid
        return false
      end if


      if m.isRedrawToCanvasRequired(rendererObj, drawMode)
        ' either this moved recently, changed or not supposed to use temp bitmap in this drawMode
        if m.objMovedInRelationToCamera(rendererObj.camera)
          transformDetails = m.attemptTransformTempBitmap(rendererObj, drawMode)
          if invalid <> transformDetails
            ' the object moved, but the temporary bitmap can be reused
            m.hasAccurateTempBitmap = false
            region = CreateObject("roRegion", m.tempBitmap, 0, 0, m.tempBitmap.GetWidth(), m.tempBitmap.GetHeight())
            retVal = rendererObj.drawScaledAndRotatedObject(transformDetails.origin.x, transformDetails.origin.y, transformDetails.scaleX, transformDetails.scaleY, transformDetails.rotation, region)
          end if
        end if
        if not retVal
          ' we have not drawn anything yet
          if isDirectDrawMode(drawMode)
            retval = m.drawToCanvas(rendererObj, drawMode)
          else
            ' try to create a temp bitmap and draw it to the
            m.tempBitmap = m.createTempBitmap(canvasBounds, rendererObj, drawMode)
            if invalid <> m.tempBitmap
              retVal = rendererObj.drawObject(canvasBounds[0].x, canvasBounds[0].y, m.tempBitmap)
            end if
          end if
        end if
      else
        ' nothing changed since last frame
        if invalid = m.tempBitmap
          ' draw a static image that can be used later
          m.tempBitmap = m.createTempBitmap(canvasBounds, rendererObj, drawMode)
        end if
        retVal = rendererObj.drawObject(canvasBounds[0].x, canvasBounds[0].y, m.tempBitmap)
      end if

      if isOrientedDrawMode(drawMode) and invalid <> m.normalOnCanvasStart and invalid <> m.normalOnCanvasEnd
        ' normalOnCanvasStart, normalOnCanvasEnd will only be set if in debug mode
        rendererObj.drawLine(m.normalOnCanvasStart.x, m.normalOnCanvasStart.y, m.normalOnCanvasEnd.x, m.normalOnCanvasEnd.y, BGE.Colors().Pink)
      end if

      if not retVal
        ' nothing was drawn to the screen
        m.tempBitmap = invalid
      end if

      return retVal
    end function

    protected function isRedrawToCanvasRequired(rendererObj as BGE.Renderer, drawMode as SceneObjectDrawMode) as boolean
      return not m.useTempBitmapMap[drawMode] or m.objMovedInRelationToCamera(rendererObj.camera) or m.didRegionToDrawChange() or m.tempBitmap = invalid or m.hasAccurateTempBitmap = false
    end function

    protected function createTempBitmap(canvasBounds as BGE.Math.Vector[], rendererObj as Renderer, drawMode as SceneObjectDrawMode) as roBitmap
      if invalid = canvasBounds or canvasBounds.count() < 2
        return invalid
      end if
      canvasSize = canvasBounds[1].subtract(canvasBounds[0])
      if canvasSize.x < 2 or canvasSize.y < 2
        return invalid
      end if
      tempBitmap = createObject("roBitmap", {width: canvasSize.x + 1, height: canvasSize.y + 1, alphaEnable: true})
      tempBitmapDrawn = m.drawToTempBitmap(rendererObj, tempBitmap, canvasBounds[0], drawMode)
      if not tempBitmapDrawn
        m.limitPointMap = invalid
        return invalid
      end if
      m.limitPointMap = m.getCanvasLimitPointMap()
      m.hasAccurateTempBitmap = true
      return tempBitmap
    end function

    protected function drawToCanvas(rendererObj as BGE.Renderer, drawMode as SceneObjectDrawMode) as boolean
      regionToDraw = m.getRegionWithIdToDraw()
      regionObj = regionToDraw.region
      if invalid = regionToDraw or invalid = regionObj
        return false
      end if
      if drawMode = BGE.SceneObjectDrawMode.directToCamera
        drawPos = m.canvasPosition
        totalScaleX = 1.0 * m.drawable.scale.x * m.drawable.owner.scale.x
        totalScaleY = 1.0 * m.drawable.scale.y * m.drawable.owner.scale.y
        theta = m.drawable.rotation.z + m.drawable.owner.rotation.z

        retVal = rendererObj.drawRegion(regionToDraw.region, drawPos.x, drawPos.y, totalScaleX, totalScaleY, -theta)
      else if drawMode = BGE.SceneObjectDrawMode.oriented
        retVal = rendererObj.drawPinnedCorners(m.canvasPoints, regionToDraw, m.isMirror, m.drawable.getFillColorRGBA())
      end if
      return retVal
    end function

    private function getCanvasBounds() as BGE.Math.Vector[]
      return BGE.Math.getBounds(m.getAllCanvasPoints())
    end function

    protected function getAllCanvasPoints() as BGE.Math.Vector[]
      return m.canvasPoints.toArray()
    end function

    private function getCanvasLimitPointMap() as LimitPointMappings
      return new LimitPointMappings(m.getAllCanvasPoints())
    end function

    private function getCurrentLimitPointsFromMap() as LimitPoints2d
      if rodash.isInvalid(m.limitPointMap)
        return invalid
      end if
      currentCanvasPoints = m.getAllCanvasPoints()

      if currentCanvasPoints.Count() <> m.limitPointMap.totalPointCount
        return invalid
      end if
      currentLimits = {
        top: currentCanvasPoints[m.limitPointMap.topIndex]
        left: currentCanvasPoints[m.limitPointMap.leftIndex]
        bottom: currentCanvasPoints[m.limitPointMap.bottomIndex]
        right: currentCanvasPoints[m.limitPointMap.rightIndex]
      }
      return currentLimits
    end function

    protected function getRegionWithIdToDraw() as RegionWithId
      return invalid
    end function

    protected function drawToTempBitmap(rendererObj as BGE.Renderer, tempBitmap as ifDraw2d, canvasPointsTopLeftBound as BGE.Math.Vector, drawMode as SceneObjectDrawMode) as boolean
      if invalid = tempBitmap
        return false
      end if

      regionToDraw = m.getRegionWithIdToDraw()
      if invalid = regionToDraw or invalid = regionToDraw.region
        return false
      end if
      regionObj = regionToDraw.region
      preTransX = regionObj.getPretranslationX()
      preTransY = regionObj.getPretranslationY()
      offsetCanvasPoints = m.canvasPoints.subtract(canvasPointsTopLeftBound)
      m.tempBitmapPoints = offsetCanvasPoints.toArray()

      regionObj.setPretranslation(0, 0)
      tempBmpDidDraw = rendererObj.drawPinnedCornersTo(tempBitmap, offsetCanvasPoints, regionToDraw, m.isMirror, m.drawable.getFillColorRGBA())
      regionObj.setPretranslation(preTransX, preTransY)
      return tempBmpDidDraw
    end function


    protected function didRegionToDrawChange() as boolean
      return false
    end function

    protected override function updateWorldPosition(drawMode as SceneObjectDrawMode) as boolean
      if drawMode = BGE.SceneObjectDrawMode.directToCamera or drawMode = BGE.SceneObjectDrawMode.matchCamera
        m.worldPosition = m.drawable.getWorldPosition()

      else
        ' All oriented draw modes
        origin = new BGE.Math.Vector()
        totalScaleX = 1 * m.drawable.scale.x
        totalScaleY = 1 * m.drawable.scale.y
        scaledSize = m.drawable.getDrawnSize()
        scaledWidth = scaledSize.width
        scaledHeight = scaledSize.height
        pretrans = m.drawable.getPretranslation()
        topLeft = new BGE.Math.Vector(pretrans.x * totalScaleX, -pretrans.y * totalScaleY, 0)
        topRight = topLeft.add(new BGE.Math.Vector(scaledWidth, 0, 0))
        bottomLeft = topLeft.add(new BGE.Math.Vector(0, -scaledHeight, 0))
        bottomRight = topLeft.add(new BGE.Math.Vector(scaledWidth, -scaledHeight, 0))

        m.worldPoints.topLeft = m.transformationMatrix.multVecMatrix(topLeft)
        m.worldPoints.topRight = m.transformationMatrix.multVecMatrix(topRight)
        m.worldPoints.bottomLeft = m.transformationMatrix.multVecMatrix(bottomLeft)
        m.worldPoints.bottomRight = m.transformationMatrix.multVecMatrix(bottomRight)
        m.worldPosition = m.worldPoints.topLeft

        m.surfaceNormal = m.worldPoints.getNormal()
      end if
      return true
    end function


    override function getPositionForCameraDistance(drawMode as SceneObjectDrawMode) as BGE.Math.Vector
      if isOrientedDrawMode(drawMode)
        return m.worldPoints.getCenter()
      end if
      return m.worldPosition
    end function

    override function getPositionsForFrustumCheck(drawMode as SceneObjectDrawMode) as BGE.Math.Vector[]
      if isOrientedDrawMode(drawMode)
        return m.worldPoints.toArray()
      end if
      return [m.worldPosition]
    end function

    protected override function findCanvasPosition(rendererObj as Renderer, drawMode as SceneObjectDrawMode) as boolean

      result = m.updateCanvasPosition(rendererObj, drawMode)
      if result and isOrientedDrawMode(drawMode)
        m.computeNormalDebugInfo(rendererObj)
        m.isMirror = false
        if invalid <> m.surfaceNormal
          m.surfaceToCameraDotProduct = m.surfaceNormal.dotProduct(rendererObj.camera.orientation)
          if m.surfaceToCameraDotProduct < 0
            m.isMirror = true
          end if
        end if
      end if
      return result
    end function


    protected function updateCanvasPosition(rendererObj as Renderer, drawMode as SceneObjectDrawMode) as boolean
      if isDirectDrawMode(drawMode)
        m.canvasPosition = rendererObj.worldPointToCanvasPoint(m.worldPosition)
        if invalid = m.canvasPosition
          return false
        end if
      else if isOrientedDrawMode(drawMode)
        index = 0
        for each corner in m.worldPoints.toArray()
          canvasPoint = rendererObj.worldPointToCanvasPoint(corner)
          if invalid = canvasPoint
            return false
          end if
          m.canvasPoints.setPointByIndex(index, canvasPoint)
          index++
        end for
      end if
      return true
    end function


    protected sub computeNormalDebugInfo(rendererObj as Renderer)
      if isTrue(m.drawable.owner.game.getDebugValue("draw_scene_object_normals")) and invalid <> m.surfaceNormal and invalid <> m.worldPoints
        normalCenter = m.getNormalDebugPoint()
        m.normalOnCanvasStart = rendererObj.worldPointToCanvasPoint(m.worldPoints.getCenter())
        m.normalOnCanvasEnd = rendererObj.worldPointToCanvasPoint(m.worldPoints.getCenter().subtract(m.surfaceNormal.scale(100)))
      else
        m.normalOnCanvasStart = invalid
        m.normalOnCanvasEnd = invalid
      end if
    end sub

    protected function getNormalDebugPoint() as BGE.Math.Vector
      return m.worldPoints.getCenter()
    end function


    ' Determine if we can just scale and/or rotate the temp bitmap to match the required position
    protected function attemptTransformTempBitmap(renderObj as Renderer, drawMode as SceneObjectDrawMode) as TransformTempBitmapDetails
      if rodash.isInvalid(m.tempBitmap) or rodash.isInvalid(m.limitPointMap) or not m.useTempBitmapMap[drawMode]
        return invalid
      end if

      if m.limitPointMap.height = invalid or m.limitPointMap.height < 2 or m.limitPointMap.width = invalid or m.limitPointMap.width < 2
        return invalid
      end if

      currentLimits = m.getCurrentLimitPointsFromMap()

      if rodash.isInvalid(currentLimits)
        return invalid
      end if

      rotationDelta = m.limitPointMap.getAngleBaseLineDifference(currentLimits)

      ' rotate the current points to be axis aligned, so we can get the mappedOrigin - this allows us to read x & y sclaes
      currentBackRotationMatrix = BGE.Math.getTransformationMatrix(new BGE.Math.Vector(),
      new BGE.Math.Vector(0, 0, rotationDelta),
      BGE.Math.Vector(1, 1)
      )
      backRotatedCurrent = {
        left: currentBackRotationMatrix.multVecMatrix(currentLimits.left),
        top: currentBackRotationMatrix.multVecMatrix(currentLimits.top),
        right: currentBackRotationMatrix.multVecMatrix(currentLimits.right),
        bottom: currentBackRotationMatrix.multVecMatrix(currentLimits.bottom),
      } as LimitPoints2d


      d = backRotatedCurrent.left.y - backRotatedCurrent.top.y ' distance From MappedOrigin To CurrentLeft
      reRotation = BGE.Math.HalfPi() - rotationDelta
      ' get the mapped origin by applying the distance From MappedOrigin To CurrentLeft
      mappedOrigin = new BGE.Math.vector(currentLimits.left.x + d * cos(-reRotation), currentLimits.left.y + d * sin(-reRotation))

      newVertScale = abs(backRotatedCurrent.top.y - backRotatedCurrent.bottom.y) / m.limitPointMap.height
      newHorizScale = (backRotatedCurrent.right.x - backRotatedCurrent.left.x) / m.limitPointMap.width

      originDelta = mappedOrigin.subtract(m.limitPointMap.origin)
      ' compare canvas points vs. scaled points from mappedOrigin

      tempTranslationTransformMatrix = BGE.Math.getTransformationMatrix(
      originDelta,
      new BGE.Math.Vector(0, 0, rotationDelta),
      new BGE.Math.Vector(newHorizScale, newVertScale)
      )
      transformedLeft = tempTranslationTransformMatrix.multVecMatrix(m.limitPointMap.left)
      transformedTop = tempTranslationTransformMatrix.multVecMatrix(m.limitPointMap.top)

      transformedRight = tempTranslationTransformMatrix.multVecMatrix(m.limitPointMap.right)
      transformedBottom = tempTranslationTransformMatrix.multVecMatrix(m.limitPointMap.bottom)

      topDelta = transformedTop.subtract(currentLimits.top).manhattanLength()
      leftDelta = transformedLeft.subtract(currentLimits.left).manhattanLength()
      rightDelta = transformedRight.subtract(currentLimits.right).manhattanLength()
      bottomDelta = transformedBottom.subtract(currentLimits.bottom).manhattanLength()

      totalDifference = topDelta + leftDelta + rightDelta + bottomDelta
      maxDifference = BGE.Math.arrayMax([topDelta, leftDelta, rightDelta, bottomDelta])

      if maxDifference < 24 ' TODO: MAGIC NUMBER!!
        return {
          origin: mappedOrigin,
          rotation: rotationDelta,
          scaleX: newHorizScale,
          scaleY: newVertScale
        }
      end if

      return invalid
    end function



    ' Is this a back and then we should not draw it?
    '
    ' @param {SceneObjectDrawMode} drawMode - some drawModes explicitly should draw the backface
    ' @return {boolean} true if we should not draw
    protected function doNotDrawBecauseBackFace(drawMode as SceneObjectDrawMode) as boolean
      if m.isMirror
        if drawMode = SceneObjectDrawMode.orientedDrawBackFace or drawMode = SceneObjectDrawMode.wireFrameDrawBackFace
          return false
        end if
        return true
      end if
      return false
    end function

  end class

end namespace