namespace BGE

  class SceneObjectBillboard extends SceneObject


    private worldPoints as BGE.Math.CornerPoints = new BGE.Math.CornerPoints()
    private canvasPoints as BGE.Math.CornerPoints = new BGE.Math.CornerPoints()

    private canvasPosition as BGE.Math.Vector

    private isMirror = false

    private surfaceToCameraDotProduct as float
    private surfaceNormal as BGE.Math.Vector
    private normalOnCanvasStart as BGE.Math.Vector
    private normalOnCanvasEnd as BGE.Math.Vector

    private tempBitmap as ifDraw2d = invalid

    private limitPointMap as LimitPointMappings = invalid

    protected useTempBitmapMap as boolean[] = [false, false, false]

    frameCount = 0

    sub new(name as string, drawableObj as Drawable, objType as SceneObjectType)
      super(name, drawableObj, objType)
      m.useTempBitmapMap[SceneObjectDrawMode.matchCamera] = false
      m.useTempBitmapMap[SceneObjectDrawMode.directToCamera] = false
      m.useTempBitmapMap[SceneObjectDrawMode.attemptToOrient] = true
    end sub

    protected override function performDraw(rendererObj as BGE.Renderer, drawMode as SceneObjectDrawMode) as boolean
      retVal = false
      canvasBounds = m.getCanvasBounds()
      if m.isMirror
        ' This face is facing backwards
        m.tempBitmap = invalid
        return false
      end if
      if m.isRedrawToCanvasRequired(rendererObj, drawMode)
        ' either this moved recently, changed or not supposed to use temp bitmap in this drawMode

        if m.canAttemptTransformTempBitmap(drawMode)


        end if
        if not retVal
          if drawMode = BGE.SceneObjectDrawMode.directToCamera
            retval = m.drawToCanvas(rendererObj, drawMode)
          else

            m.tempBitmap = m.createTempBitmap(canvasBounds, rendererObj, drawMode)
            if invalid <> m.tempBitmap
              retVal = rendererObj.drawObject(canvasBounds[0].x, canvasBounds[0].y, m.tempBitmap)
            end if
          end if
        end if
      else
        ' nothing changed since last frame, draw a static image that can be used later
        if invalid = m.tempBitmap
          m.tempBitmap = m.createTempBitmap(canvasBounds, rendererObj, drawMode)
        end if
        retVal = rendererObj.drawObject(canvasBounds[0].x, canvasBounds[0].y, m.tempBitmap)

      end if

      if drawMode = BGE.SceneObjectDrawMode.attemptToOrient and invalid <> m.normalOnCanvasStart and invalid <> m.normalOnCanvasEnd
        rendererObj.drawLine(m.normalOnCanvasStart.x, m.normalOnCanvasStart.y, m.normalOnCanvasEnd.x, m.normalOnCanvasEnd.y, BGE.Colors().Pink)
      end if

      if not retVal
        m.tempBitmap = invalid
      end if

      return retVal
    end function

    protected function isRedrawToCanvasRequired(rendererObj as BGE.Renderer, drawMode as SceneObjectDrawMode) as boolean
      return not m.useTempBitmapMap[drawMode] or m.objMovedInRelationToCamera(rendererObj.camera) or m.didRegionToDrawChange()
    end function




    protected function createTempBitmap(canvasBounds as BGE.Math.Vector[], rendererObj as Renderer, drawMode as SceneObjectDrawMode) as roBitmap
      if invalid = canvasBounds or canvasBounds.count() < 2
        return invalid
      end if
      canvasSize = canvasBounds[1].subtract(canvasBounds[0])
      tempBitmap = createObject("roBitmap", {width: canvasSize.x + 1, height: canvasSize.y + 1, alphaEnable: true})
      tempBitmapDrawn = m.drawToTempBitmap(rendererObj, tempBitmap, canvasBounds[0], drawMode)
      if not tempBitmapDrawn
        m.limitPointMap = invalid
        return invalid
      end if
      m.limitPointMap = m.getCanvasLimitPointMap()
      return tempBitmap
    end function

    protected function drawToCanvas(rendererObj as BGE.Renderer, drawMode as SceneObjectDrawMode) as boolean
      regionToDraw = m.getRegionWithIdToDraw()
      regionObj = regionToDraw.region
      if invalid = regionToDraw or invalid = regionObj
        return false
      end if
      if drawMode = BGE.SceneObjectDrawMode.directToCamera
        drawPos = m.canvasPosition
        totalScaleX = 1.0 * m.drawable.scale.x * m.drawable.owner.scale.x
        totalScaleY = 1.0 * m.drawable.scale.y * m.drawable.owner.scale.y
        theta = m.drawable.rotation.z + m.drawable.owner.rotation.z

        retVal = rendererObj.drawRegion(regionToDraw.region, drawPos.x, drawPos.y, totalScaleX, totalScaleY, -theta)
      else if drawMode = BGE.SceneObjectDrawMode.attemptToOrient
        retVal = rendererObj.drawPinnedCorners(m.canvasPoints, regionToDraw, m.isMirror, m.drawable.getFillColorRGBA())
      end if
      return retVal
    end function

    private function getCanvasBounds() as BGE.Math.Vector[]
      return BGE.Math.getBounds(m.getAllCanvasPoints())
    end function

    protected function getAllCanvasPoints() as BGE.Math.Vector[]
      return m.canvasPoints.toArray()
    end function

    private function getCanvasLimitPointMap() as LimitPointMappings
      return new LimitPointMappings(m.getAllCanvasPoints())
    end function

    private function getCurrentLimitPointsFromMap() as LimitPoints2d
      if rodash.isInvalid(m.limitPointMap)
        return invalid
      end if
      currentCanvasPoints = m.getAllCanvasPoints()

      if currentCanvasPoints.Count() <> m.limitPointMap.totalPointCount
        return invalid
      end if
      currentLimits = {
        top: currentCanvasPoints[m.limitPointMap.topIndex]
        left: currentCanvasPoints[m.limitPointMap.leftIndex]
        bottom: currentCanvasPoints[m.limitPointMap.bottomIndex]
        right: currentCanvasPoints[m.limitPointMap.rightIndex]
      }
      return currentLimits
    end function

    protected function getRegionWithIdToDraw() as RegionWithId
      return invalid
    end function

    protected function drawToTempBitmap(rendererObj as BGE.Renderer, tempBitmap as ifDraw2d, canvasPointsTopLeftBound as BGE.Math.Vector, drawMode as SceneObjectDrawMode) as boolean
      if invalid = tempBitmap
        return false
      end if

      regionToDraw = m.getRegionWithIdToDraw()
      if invalid = regionToDraw or invalid = regionToDraw.region
        return false
      end if
      regionObj = regionToDraw.region
      preTransX = regionObj.getPretranslationX()
      preTransY = regionObj.getPretranslationY()
      offsetCanvasPoints = m.canvasPoints.subtract(canvasPointsTopLeftBound)
      m.tempBitmapPoints = offsetCanvasPoints.toArray()

      regionObj.setPretranslation(0, 0)
      tempBmpDidDraw = rendererObj.drawPinnedCornersTo(tempBitmap, offsetCanvasPoints, regionToDraw, m.isMirror, m.drawable.getFillColorRGBA())
      regionObj.setPretranslation(preTransX, preTransY)
      return tempBmpDidDraw
    end function


    protected function didRegionToDrawChange() as boolean
      return false
    end function

    protected override function updateWorldPosition(drawMode as SceneObjectDrawMode) as boolean
      if drawMode = BGE.SceneObjectDrawMode.directToCamera
        m.worldPosition = m.drawable.getWorldPosition()

      else if drawMode = BGE.SceneObjectDrawMode.attemptToOrient
        origin = new BGE.Math.Vector()
        totalScaleX = 1 * m.drawable.scale.x
        totalScaleY = 1 * m.drawable.scale.y
        scaledSize = m.drawable.getDrawnSize()
        scaledWidth = scaledSize.width
        scaledHeight = scaledSize.height
        pretrans = m.drawable.getPretranslation()
        topLeft = new BGE.Math.Vector(pretrans.x * totalScaleX, -pretrans.y * totalScaleY, 0)
        topRight = topLeft.add(new BGE.Math.Vector(scaledWidth, 0, 0))
        bottomLeft = topLeft.add(new BGE.Math.Vector(0, -scaledHeight, 0))
        bottomRight = topLeft.add(new BGE.Math.Vector(scaledWidth, -scaledHeight, 0))

        m.worldPoints.topLeft = m.transformationMatrix.multVecMatrix(topLeft)
        m.worldPoints.topRight = m.transformationMatrix.multVecMatrix(topRight)
        m.worldPoints.bottomLeft = m.transformationMatrix.multVecMatrix(bottomLeft)
        m.worldPoints.bottomRight = m.transformationMatrix.multVecMatrix(bottomRight)
        m.worldPosition = m.worldPoints.topLeft

        m.surfaceNormal = m.worldPoints.getNormal()
      end if
      return true
    end function


    override function getPositionForCameraDistance(drawMode as SceneObjectDrawMode) as BGE.Math.Vector
      if drawMode = BGE.SceneObjectDrawMode.attemptToOrient
        return m.worldPoints.getCenter()
      end if
      return m.worldPosition
    end function

    override function getPositionsForFrustumCheck(drawMode as SceneObjectDrawMode) as BGE.Math.Vector[]
      if drawMode = BGE.SceneObjectDrawMode.attemptToOrient
        return m.worldPoints.toArray()
      end if
      return [m.worldPosition]
    end function

    protected override function findCanvasPosition(rendererObj as Renderer, drawMode as SceneObjectDrawMode) as boolean

      result = m.updateCanvasPosition(rendererObj, drawMode)
      if result and drawMode = BGE.SceneObjectDrawMode.attemptToOrient
        m.computeNormalDebugInfo(rendererObj)
        m.isMirror = false
        if invalid <> m.surfaceNormal
          m.surfaceToCameraDotProduct = m.surfaceNormal.dotProduct(rendererObj.camera.orientation)
          if m.surfaceToCameraDotProduct < 0
            m.isMirror = true
          end if
        end if
      end if
      return result
    end function


    protected function updateCanvasPosition(rendererObj as Renderer, drawMode as SceneObjectDrawMode) as boolean
      if drawMode = BGE.SceneObjectDrawMode.directToCamera
        m.canvasPosition = rendererObj.worldPointToCanvasPoint(m.worldPosition)
        if invalid = m.canvasPosition
          return false
        end if
      else if drawMode = BGE.SceneObjectDrawMode.attemptToOrient
        index = 0
        for each corner in m.worldPoints.toArray()
          canvasPoint = rendererObj.worldPointToCanvasPoint(corner)
          if invalid = canvasPoint
            return false
          end if
          m.canvasPoints.setPointByIndex(index, canvasPoint)
          index++
        end for
      end if
      return true
    end function


    protected sub computeNormalDebugInfo(rendererObj as Renderer)
      if isTrue(m.drawable.owner.game.getDebugValue("draw_scene_object_normals")) and invalid <> m.surfaceNormal and invalid <> m.worldPoints
        normalCenter = m.getNormalDebugPoint()
        m.normalOnCanvasStart = rendererObj.worldPointToCanvasPoint(m.worldPoints.getCenter())
        m.normalOnCanvasEnd = rendererObj.worldPointToCanvasPoint(m.worldPoints.getCenter().subtract(m.surfaceNormal.scale(100)))
      else
        m.normalOnCanvasStart = invalid
        m.normalOnCanvasEnd = invalid
      end if
    end sub

    protected function getNormalDebugPoint() as BGE.Math.Vector
      return m.worldPoints.getCenter()
    end function


    ' Determine if we can just scale and/or rotate the temp bitmap to match the required position
    protected function canAttemptTransformTempBitmap(drawMode as SceneObjectDrawMode) as boolean
      if rodash.isInvalid(m.tempBitmap) or rodash.isInvalid(m.limitPointMap) or not m.useTempBitmapMap[drawMode]
        return false
      end if

      ' check points to see if
      currentLimits = m.getCurrentLimitPointsFromMap()
      if rodash.isInvalid(currentLimits)
        return false
      end if

      '
      '   ?-----B
      '   |   /
      '   |  /
      '   |a/
      '   A
      ' get aAngle

      currentTLBAngle = BGE.Math.GetAngleBetweenVectors(currentLimits.left, currentLimits.top, currentLimits.bottom)
      k = m.limitPointMap.alphaBetaRatio
      currentAlphaAngle = k * (BGE.Math.PI() - currentTLBAngle) / (k + 1)

      ' from currentLimits.left currentLimits.top aAngle, get mappedOrigin
      mappedOrigin = BGE.Math.getThirdRightTrianglePoint(currentLimits.left, currentLimits.top, currentAlphaAngle)
      testRotationOfTemp = BGE.Math.GetAngle(mappedOrigin, currentLimits.top)


      ' from mapped origin get horizScale & vertScale
      if m.limitPointMap.originLeftDistance = 0
        print "can not transform! (bad vert) - origin: ";m.limitPointMap.origin.toStr();" left: ";m.limitPointMap.left.toStr()
        return false
      end if
      if m.limitPointMap.originTopDistance = 0
        print "can not transform!  (bad horiz) - origin: ";m.limitPointMap.origin.toStr();" top: ";m.limitPointMap.top.toStr()
        return false
      end if

      newVertScale = mappedOrigin.subtract(currentLimits.left).length() / m.limitPointMap.originLeftDistance
      newHorizScale = mappedOrigin.subtract(currentLimits.top).length() / m.limitPointMap.originTopDistance

      ' compare canvas points vs. scaled points from mappedOrigin
      tempTranslationTransformMatrix = BGE.Math.getTransformationMatrix(
      new BGE.Math.Vector(),
      new BGE.Math.Vector(0, 0, testRotationOfTemp),
      new BGE.Math.Vector(newHorizScale, newVertScale)
      )

      rightDelta = tempTranslationTransformMatrix.multVecMatrix(m.limitPointMap.right).subtract(currentLimits.right).manhattanLength()
      bottomDelta = tempTranslationTransformMatrix.multVecMatrix(m.limitPointMap.bottom).subtract(currentLimits.bottom).manhattanLength()

      totalDifference = rightDelta + bottomDelta

      ?"totalDifference: ";totalDifference


      return false
    end function

  end class

end namespace