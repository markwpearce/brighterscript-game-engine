namespace BGE

  class SceneObjectImage extends SceneObject

    drawable as Image


    private worldPoints as BGE.Math.CornerPoints = new BGE.Math.CornerPoints()
    private canvasPoints as BGE.Math.CornerPoints = new BGE.Math.CornerPoints()


    private worldPosition as BGE.Math.Vector
    private canvasPosition as BGE.Math.Vector

    private isMirror = false
    private orientationScaleX as float
    private orientationScaleY as float
    private orientationRotation as float
    private surfaceToCameraDotProduct as float
    private surfaceNormal as BGE.Math.Vector

    public frameNumber as integer = 0


    sub new(name as string, drawableObj as Image)
      super(name, drawableObj, BGE.SceneObjectType.Bitmap)
    end sub

    protected override function performDraw(renderer as BGE.Renderer, drawMode as SceneObjectDrawMode) as boolean
      retVal = false

      if drawMode = BGE.SceneObjectDrawMode.directToCamera
        drawPos = m.canvasPosition
        scaleX = m.drawable.scale.x
        scaleY = m.drawable.scale.y
        theta = m.drawable.rotation.z + m.drawable.owner.rotation.z

        retVal = renderer.drawRegion(m.drawable.region, drawPOs.x, drawPos.y, scaleX, ScaleY, -theta)
      else if drawMode = BGE.SceneObjectDrawMode.attemptToOrient
        if m.isMirror
          return true
        end if
        regionId = m.getUniqueRegionName()
        drawableRegion = new RegionWithId(m.drawable.region, regionId)
        retVal = renderer.drawPinnedCorners(m.canvasPoints, drawableRegion, m.isMirror)
      end if

      return retVal
    end function

    protected function getUniqueRegionName() as string
      return m.name + "_" + m.id + "_" + m.frameNumber.toStr()
    end function

    protected override sub updateWorldPosition(drawMode as SceneObjectDrawMode)
      if drawMode = BGE.SceneObjectDrawMode.directToCamera
        m.worldPosition = m.drawable.getWorldPosition()

      else if drawMode = BGE.SceneObjectDrawMode.attemptToOrient
        origin = new BGE.Math.Vector()
        scaledWidth = m.drawable.region.getWidth() * m.drawable.scale.x
        scaledHeight = m.drawable.region.getHeight() * m.drawable.scale.y
        topLeft = new BGE.Math.Vector()
        topRight = new BGE.Math.Vector(scaledWidth, 0, 0)
        bottomLeft = new BGE.Math.Vector(0, -scaledHeight, 0)
        bottomRight = new BGE.Math.Vector(scaledWidth, -scaledHeight, 0)

        m.worldPoints.topLeft = m.transformationMatrix.multVecMatrix(topLeft)
        m.worldPoints.topRight = m.transformationMatrix.multVecMatrix(topRight)
        m.worldPoints.bottomLeft = m.transformationMatrix.multVecMatrix(bottomLeft)
        m.worldPoints.bottomRight = m.transformationMatrix.multVecMatrix(bottomRight)

        m.surfaceNormal = m.worldPoints.getNormal()
      end if
    end sub


    override function getPositionForCameraDistance() as BGE.Math.Vector
      return m.worldPoints.getCenter()
    end function

    override function getPositionsForFrustumCheck() as BGE.Math.Vector[]
      return m.worldPoints.toArray()
    end function

    protected override function findCanvasPosition(renderer as Renderer, drawMode as SceneObjectDrawMode) as boolean
      if drawMode = BGE.SceneObjectDrawMode.directToCamera
        m.canvasPosition = renderer.worldPointToCanvasPoint(m.worldPosition)
        if invalid = m.canvasPosition
          return false
        end if
      else if drawMode = BGE.SceneObjectDrawMode.attemptToOrient
        index = 0
        for each corner in m.worldPoints.toArray()
          canvasPoint = renderer.worldPointToCanvasPoint(corner)
          if invalid = canvasPoint
            return false
          end if
          m.canvasPoints.setPointByIndex(index, canvasPoint)
          index++
        end for

        m.surfaceToCameraDotProduct = m.surfaceNormal.dotProduct(renderer.camera.orientation)
        m.isMirror = false
        if m.surfaceToCameraDotProduct < 0
          m.isMirror = true
        end if
      end if
      return true
    end function

  end class

end namespace