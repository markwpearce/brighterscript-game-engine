namespace BGE

  enum SceneObjectImageDrawMode
    directToCamera = 0
    attemptToOrient = 1
  end enum

  class SceneObjectImage extends SceneObject

    drawable as Image

    drawMode as SceneObjectImageDrawMode = BGE.SceneObjectImageDrawMode.attemptToOrient


    private worldPoints as BGE.Math.CornerPoints = new BGE.Math.CornerPoints()
    private canvasPoints as BGE.Math.CornerPoints = new BGE.Math.CornerPoints()


    private worldPosition as BGE.Math.Vector
    private canvasPosition as BGE.Math.Vector

    private isMirror = false
    private orientationScaleX as float
    private orientationScaleY as float
    private orientationRotation as float
    private surfaceToCameraDotProduct as float
    private surfaceNormal as BGE.Math.Vector

    private validCanvasPosition = false


    sub new(name as string, drawableObj as Image)
      super(name, drawableObj, BGE.SceneObjectType.Bitmap)
    end sub

    protected override function performDraw(renderer as BGE.Renderer) as boolean
      if m.drawable.movedLastFrame(true) or invalid = m.worldPosition
        m.findWorldPosition()
      end if
      if renderer.camera.movedLastFrame() or m.drawable.movedLastFrame(true) or invalid = m.canvasPosition
        m.validCanvasPosition = m.findCanvasPosition(renderer)
      end if

      if not m.validCanvasPosition
        return false
      end if

      return m.drawToCanvas(renderer)
    end function



    protected sub findWorldPosition()
      if m.drawMode = BGE.SceneObjectImageDrawMode.directToCamera
        m.worldPosition = m.drawable.getWorldPosition()

      else if m.drawMode = BGE.SceneObjectImageDrawMode.attemptToOrient
        ' pretranslation_x = m.drawable.GetPretranslationX()
        ' pretranslation_y = m.drawable.GetPretranslationY()
        ' newPreX = pretranslation_x * scale_x
        ' if scale_x < 0
        '   newPreX = -newPreX
        ' end if
        ' newPreY = pretranslation_y * scale_y
        ' if scale_y < 0
        '   newPreY = -newPreY
        ' end if


        origin = m.drawable.offset
        scaledWidth = -m.drawable.region.getWidth() * m.drawable.scale.x
        scaledHeight = m.drawable.region.getHeight() * m.drawable.scale.y
        tl = origin
        topR = origin.add(new BGE.Math.Vector(scaledWidth, 0, 0))
        bl = origin.add(new BGE.Math.Vector(0, -scaledHeight, 0))
        br = origin.add(new BGE.Math.Vector(scaledWidth, -scaledHeight, 0))



        m.worldPoints.topLeft = m.transformationMatrix.multVecMatrix(tl)
        m.worldPoints.topRight = m.transformationMatrix.multVecMatrix(topR)
        m.worldPoints.bottomLeft = m.transformationMatrix.multVecMatrix(bl)
        m.worldPoints.bottomRight = m.transformationMatrix.multVecMatrix(br)


        m.surfaceNormal = m.worldPoints.getNormal()

      end if


      'renderRotation = m.drawable.rotation.subtract(renderer.camera.orientation)
      ' could also use rotation to decide scale
      ' return renderer.drawScaledAndRotatedObject(renderPosition.x, renderPosition.y, m.drawable.scale.x, m.drawable.scale.y, renderRotation.z, m.drawable.region)

    end sub

    protected function findCanvasPosition(renderer as Renderer) as boolean
      if m.drawMode = BGE.SceneObjectImageDrawMode.directToCamera
        m.canvasPosition = renderer.worldPointToCanvasPoint(m.worldPosition)

      else if m.drawMode = BGE.SceneObjectImageDrawMode.attemptToOrient
        index = 0
        for each corner in m.worldPoints.toArray()
          canvasPoint = renderer.worldPointToCanvasPoint(corner)
          if invalid = canvasPoint
            return false
          end if
          m.canvasPoints.setPointByIndex(index, canvasPoint)
          index++
        end for

        '?m.canvasPoints.toStr()

        avgXDelta = m.canvasPoints.getAvgWidth()
        avgYDelta = m.canvasPoints.getAvgHeight()

        m.orientationScaleX = (avgXDelta / m.drawable.region.getWidth())
        m.orientationScaleY = (avgYDelta / m.drawable.region.getHeight())
        originalCenter = m.canvasPoints.topLeft.copy()
        originalCenter.x += m.drawable.region.getWidth() * m.drawable.scale.x / 2
        originalCenter.y += m.drawable.region.getHeight() * m.drawable.scale.y / 2
        originalDiag = new BGE.Math.Vector(m.drawable.region.getWidth() * m.drawable.scale.x, m.drawable.region.getHeight() * m.drawable.scale.y, 0)
        m.orientationRotation = BGE.MATH.GetAngle(m.canvasPoints.topLeft, m.canvasPoints.topRight)
        m.surfaceToCameraDotProduct = m.surfaceNormal.dotProduct(renderer.camera.orientation)
        m.isMirror = false
        if m.surfaceToCameraDotProduct < 0
          m.orientationScaleX = -m.orientationScaleX
          m.orientationRotation -= BGE.Math.Pi()
          m.isMirror = true
        end if

        '? "m.surfaceNormal: "; m.surfaceNormal.toStr()
        '? "m.orientationScaleX: "; m.orientationScaleX
        '? "m.orientationScaleY: "; m.orientationScaleY
        '? "m.orientationRotation: "; m.orientationRotation
      end if
      return true
    end function


    protected function drawToCanvas(renderer as BGE.Renderer) as boolean

      drawPos = new Bge.Math.Vector()
      scaleX = 1
      scaleY = 1
      theta = 0

      if m.drawMode = BGE.SceneObjectImageDrawMode.directToCamera
        drawPos = m.canvasPosition
        scaleX = m.drawable.scale.x
        scaleY = m.drawable.scale.y
        theta = m.drawable.rotation.z
      else if m.drawMode = BGE.SceneObjectImageDrawMode.attemptToOrient
        drawPosX = m.canvasPoints.topLeft.x
        drawPosy = m.canvasPoints.topLeft.y
        scaleX = m.orientationScaleX
        scaleY = m.orientationScaleY
        theta = m.orientationRotation
      end if

      retVal = renderer.drawPinnedCorners(m.canvasPoints, m.drawable.region, m.isMirror)


      renderer.drawSquare(m.canvasPoints.topLeft.x, m.canvasPoints.topLeft.y, 10, BGE.Colors().Red)
      renderer.drawSquare(m.canvasPoints.topRight.x, m.canvasPoints.topRight.y, 10, BGE.Colors().Green)
      renderer.drawSquare(m.canvasPoints.bottomLeft.x, m.canvasPoints.bottomLeft.y, 10, BGE.Colors().Blue)
      renderer.drawSquare(m.canvasPoints.bottomRight.x, m.canvasPoints.bottomRight.y, 10, BGE.Colors().White)

      lineEndX = 300 * cos(m.orientationRotation) + m.canvasPoints.topLeft.x
      lineEndY = 300 * sin(m.orientationRotation) + m.canvasPoints.topLeft.y

      renderer.drawLine(m.canvasPoints.topLeft.x, m.canvasPoints.topLeft.y, lineEndX, lineEndY, BGE.Colors().Magenta)

      return retVal
    end function


  end class

end namespace