namespace BGE

  class SceneObjectImage extends SceneObject

    drawable as Image


    private worldPoints as BGE.Math.CornerPoints = new BGE.Math.CornerPoints()
    private canvasPoints as BGE.Math.CornerPoints = new BGE.Math.CornerPoints()


    private worldPosition as BGE.Math.Vector
    private canvasPosition as BGE.Math.Vector

    private isMirror = false

    private surfaceToCameraDotProduct as float
    private surfaceNormal as BGE.Math.Vector

    public frameNumber as integer = 0


    sub new(name as string, drawableObj as Image)
      super(name, drawableObj, BGE.SceneObjectType.Bitmap)
    end sub

    protected override function performDraw(renderer as BGE.Renderer, drawMode as SceneObjectDrawMode) as boolean
      retVal = false

      if drawMode = BGE.SceneObjectDrawMode.directToCamera
        drawPos = m.canvasPosition
        totalScaleX = 1.0 * m.drawable.scale.x * m.drawable.owner.scale.x
        totalScaleY = 1.0 * m.drawable.scale.y * m.drawable.owner.scale.y
        theta = m.drawable.rotation.z + m.drawable.owner.rotation.z

        retVal = renderer.drawRegion(m.drawable.region, drawPOs.x, drawPos.y, totalScaleX, totalScaleY, -theta)
      else if drawMode = BGE.SceneObjectDrawMode.attemptToOrient
        if m.isMirror
          return true
        end if
        regionId = m.getUniqueRegionName()
        drawableRegion = new RegionWithId(m.drawable.region, regionId)
        retVal = renderer.drawPinnedCorners(m.canvasPoints, drawableRegion, m.isMirror)
      end if

      return retVal
    end function

    protected function getUniqueRegionName() as string
      return `${m.name}_${m.frameNumber.toStr()}`
    end function

    protected override function updateWorldPosition(drawMode as SceneObjectDrawMode) as boolean
      if drawMode = BGE.SceneObjectDrawMode.directToCamera
        m.worldPosition = m.drawable.getWorldPosition()

      else if drawMode = BGE.SceneObjectDrawMode.attemptToOrient
        origin = new BGE.Math.Vector()
        totalScaleX = 1 * m.drawable.scale.x
        totalScaleY = 1 * m.drawable.scale.y
        scaledWidth = m.drawable.region.getWidth() * totalScaleX
        scaledHeight = m.drawable.region.getHeight() * totalScaleY
        pretransX = m.drawable.region.GetPretranslationX()
        pretransY = m.drawable.region.GetPretranslationX()
        topLeft = new BGE.Math.Vector(pretransX * totalScaleX, -pretransY * totalScaleY, 0)
        topRight = topLeft.add(new BGE.Math.Vector(scaledWidth, 0, 0))
        bottomLeft = topLeft.add(new BGE.Math.Vector(0, -scaledHeight, 0))
        bottomRight = topLeft.add(new BGE.Math.Vector(scaledWidth, -scaledHeight, 0))

        m.worldPoints.topLeft = m.transformationMatrix.multVecMatrix(topLeft)
        m.worldPoints.topRight = m.transformationMatrix.multVecMatrix(topRight)
        m.worldPoints.bottomLeft = m.transformationMatrix.multVecMatrix(bottomLeft)
        m.worldPoints.bottomRight = m.transformationMatrix.multVecMatrix(bottomRight)
        m.worldPosition = m.worldPoints.topLeft

        m.surfaceNormal = m.worldPoints.getNormal()
      end if
      return true
    end function


    override function getPositionForCameraDistance() as BGE.Math.Vector
      return m.worldPoints.getCenter()
    end function

    override function getPositionsForFrustumCheck() as BGE.Math.Vector[]
      return m.worldPoints.toArray()
    end function

    protected override function findCanvasPosition(renderer as Renderer, drawMode as SceneObjectDrawMode) as boolean
      if drawMode = BGE.SceneObjectDrawMode.directToCamera
        m.canvasPosition = renderer.worldPointToCanvasPoint(m.worldPosition)
        if invalid = m.canvasPosition
          return false
        end if
      else if drawMode = BGE.SceneObjectDrawMode.attemptToOrient
        index = 0
        for each corner in m.worldPoints.toArray()
          canvasPoint = renderer.worldPointToCanvasPoint(corner)
          if invalid = canvasPoint
            return false
          end if
          m.canvasPoints.setPointByIndex(index, canvasPoint)
          index++
        end for

        m.surfaceToCameraDotProduct = m.surfaceNormal.dotProduct(renderer.camera.orientation)
        m.isMirror = false
        if m.surfaceToCameraDotProduct < 0
          m.isMirror = true
        end if
      end if
      return true
    end function

  end class

end namespace