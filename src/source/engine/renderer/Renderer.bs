namespace BGE

  ' Wrapper for Draw2D calls, so that we can keep track of how much is being drawn per frame
  class Renderer

    nextSceneObjectId = 0
    ' Frame rate target - the game will reduce quality if this target is not met
    protected minimumFrameRateTarget as integer = 12

    protected onlyDrawWhenInFrame as boolean = true

    private drawCallsLastFrame = 0
    private activeDebugCells = 0
    private debugCellSize = 100
    private debugCellStart as BGE.Math.Vector = new BGE.Math.Vector(100, 100)

    private draw2d as object = invalid

    private sceneObjects as SceneObject[] = []

    camera as Camera

    cameraPosition as BGE.Math.Vector
    worldToCamera as BGE.Math.Matrix44
    cameraRotation as BGE.Math.Vector


    private game as Game

    sub new(game as BGE.Game, draw2d as object)
      m.game = game
      m.draw2d = draw2d
      m.camera = new Camera()
    end sub

    sub resetDrawCallCounter()
      m.drawCallsLastFrame = 0
      m.activeDebugCells = 0
    end sub


    sub addSceneObject(sceneObj as SceneObject)
      sceneObj.setId(m.nextSceneObjectId.toStr().trim())
      m.nextSceneObjectId++
      m.sceneObjects.push(sceneObj)
    end sub

    sub removeSceneObject(sceneObj as SceneObject)
      indexToDelete = -1
      for i = 0 to m.sceneObjects.count()
        if m.sceneObjects[i].id = sceneObj.id
          indexToDelete = i
          exit for
        end if
      end for
      if indexToDelete >= 0
        m.sceneObjects.delete(indexToDelete)
      end if
      sceneObj.id = ""
    end sub

    private sub updateSceneObjects()
      for each sceneObj in m.sceneObjects
        sceneObj.update(m.camera)
      end for

    end sub

    sub drawScene()
      m.camera.checkMovement()

      if m.camera.movedLastFrame()
        m.cameraPosition = m.camera.position' m.camera ? m.camera.position : new BGE.Math.Vector()
        lookTarget = m.camera.position.add(m.camera.orientation) ' m.camera? m.camera.orientation : new BGE.Math.Vector(0, 0, -1)
        m.worldToCamera = BGE.Math.lookAt(m.cameraPosition, lookTarget).inverse()
      end if
      m.updateSceneObjects()

      m.sceneObjects.sortBy("negDistanceFromCamera")

      ' draw sceneObjects in sorted order
      ' ignore any that are too far away (TBD) or behind camera
      for each sceneObj in m.sceneObjects
        if sceneObj.isEnabled()
          if sceneObj.negDistanceFromCamera < 0 'and sceneObj.normnegDistanceFromCamera < 10000
            sceneObj.draw(m)
          end if
        end if
      end for

    end sub


    function worldPointToCanvasPoint(pWorld as BGE.Math.Vector) as BGE.Math.Vector
      pCamera = m.worldToCamera.multVecMatrix(pWorld)
      if pCamera.z >= 0
        return invalid
      end if
      pScreen = {x: 0, y: 0}
      pScreen.x = 500 * pCamera.x / -pCamera.z
      pScreen.y = 500 * pCamera.y / -pCamera.z
      pNDC = {x: 0, y: 0}

      canvasWidth = m.draw2d.getWidth()
      canvasHeight = m.draw2d.getHeight()
      pNDC.x = (pScreen.x + canvasWidth * 0.5) / canvasWidth
      pNDC.y = (pScreen.y + canvasHeight * 0.5) / canvasHeight
      pRaster = new BGE.Math.Vector()
      imageWidth = canvasWidth
      imageHeight = canvasHeight

      pRaster.x = (pNDC.x * imageWidth)
      pRaster.y = ((1 - pNDC.y) * imageHeight)
      '? "pCamera: "; pCamera.toStr();" -> screen: [";pScreen.x;pScreen.y;"] -> NDC [";pNDC.x;pNDC.y;"] -> Raster [";pRaster.x;pRaster.y;"]"

      return pRaster
    end function



    function drawLine(x as float, y as float, endX as float, endY as float, rgba as integer) as boolean
      width = abs(x - endx)
      height = abs(y - endY)
      if not m.shouldDraw(x, y, width, height)
        return false
      end if
      m.draw2d.DrawLine(x, y, endX, endY, rgba)

      m.drawCallsLastFrame++
      return true
    end function


    function drawSquare(x as float, y as float, sideLength as float, rgba as integer) as boolean
      if not m.shouldDraw(x - sideLength / 2, y - sideLength / 2, sideLength, sideLength)
        return false
      end if
      m.draw2d.DrawPoint(x, y, sideLength, rgba)

      m.drawCallsLastFrame++
      return true
    end function

    ' Draws text to the screen
    '
    ' @param {string} text the test to display
    ' @param {integer} x
    ' @param {integer} y
    ' @param {object} font Font object to use
    ' @param {integer} [color=-1] RGBA color to use
    ' @param {string} [horizAlign="left"] Horizontal Alignment - "left", "right" or "center"
    ' @param {string} [vertAlign="left"] Vertical Alignment - "top", "bottom" or "center"
    function drawText(text as string, x as integer, y as integer, font as object, color = -1 as integer, horizAlign = "left" as string, vertAlign = "top" as string) as boolean
      width = font.GetOneLineWidth(text, 10000)
      height = font.GetOneLineHeight() * BGE.getNumberOfLinesInAString(text)
      textX = x
      textY = y

      if horizAlign = "right"
        textX = x - width
      else if horizAlign = "center"
        textX = x - width / 2
      end if

      if vertAlign = "bottom"
        textY = y - height
      else if vertAlign = "center"
        textY = y - height / 2
      end if
      if m.shouldDraw(textX, textY, width, height)
        m.draw2d.DrawText(text, textX, textY, color, font)
        m.drawCallsLastFrame++
        return true
      end if
      return false
    end function

    ' NOTE: This function is unsafe! It creates an roBitmap of the required size to be able to both scale and rotate the drawing, this action requires free video memory of the appropriate amount.
    function drawScaledAndRotatedObject(x as float, y as float, scaleX as float, scaleY as float, theta as float, drawable as object, rgba = -1 as integer, rotateAroundX = 0, rotateAroundY = 0) as boolean
      return m.drawScaledAndRotatedObjectTo(m.draw2d, x, y, scaleX, scaleY, theta, drawable, rgba)
    end function

    function drawScaledAndRotatedObjectTo(draw2D as object, x as float, y as float, scale_x as float, scale_y as float, theta as float, drawable as object, color = -1 as integer, rotateAroundX = 0, rotateAroundY = 0) as boolean
      new_width = Abs(int(drawable.GetWidth() * scale_x))
      new_height = Abs(int(drawable.GetHeight() * scale_y))
      xToDraw = x
      yToDraw = y

      if scale_x < 0 and scale_y > 0
        xToDraw = x + new_width
        ' scale_x = abs(scale_x)
      else if scale_y < 0 and scale_x > 0
        ' yToDraw = y + new_height
        '  scale_y = abs(scale_y)
      else if scale_y < 0 and scale_x < 0
        '  yToDraw = y + new_height
        ' xToDraw = x + new_width
        '  scale_y = abs(scale_y)
      end if

      if new_width <> 0 and new_height <> 0 and m.shouldDrawTo(draw2d, xToDraw, yToDraw, new_width, new_height, theta)
        scaledBitmap = CreateObject("roBitmap", {width: new_width, height: new_height, AlphaEnable: true})
        scaledRegion = CreateObject("roRegion", scaledBitmap, 0, 0, new_width, new_height)
        pretranslation_x = drawable.GetPretranslationX()
        pretranslation_y = drawable.GetPretranslationY()
        newPreX = pretranslation_x * scale_x
        scaleXdrawAdjustment = 0 ' need to change draw position if scale is negative
        scaleYdrawAdjustment = 0
        if scale_x < 0
          newPreX = -newPreX
          scaleXdrawAdjustment = new_width
        end if
        newPreY = pretranslation_y * scale_y
        if scale_y < 0
          newPreY = -newPreY
          scaleYDrawAdjustment = new_height
        end if
        scaledRegion.setPretranslation(-Abs(newPreX) + rotateAroundY, -Abs(newPreY) + rotateAroundY)
        scaled_draw_x = Abs(newPreX) + scaleXdrawAdjustment
        scaled_draw_y = Abs(newPreY) + scaleYdrawAdjustment
        scaledRegion.DrawScaledObject(scaled_draw_x, scaled_draw_y, scale_x, scale_y, drawable)
        m.drawCallsLastFrame++

        thetaDeg = BGE.Math.RadiansToDegrees(theta)

        draw2d.DrawRotatedObject(xToDraw, yToDraw, thetaDeg, scaledRegion, color)
        m.drawCallsLastFrame++
        return true
      end if
      return false
    end function

    function drawPinnedCorners(cornerPoints as BGE.Math.CornerPoints, drawable as object, isMirror = false as boolean, color = -1 as integer) as boolean
      return m.drawPinnedCornersTo(m.draw2d, cornerPoints, drawable, isMirror, color)
    end function

    function drawPinnedCornersTo(draw2D as object, cornerPoints as BGE.Math.CornerPoints, drawable as object, isMirror = false as boolean, color = -1 as integer) as boolean
      originalWidth = drawable.getWidth()
      originalHeight = drawable.getHeight()

      avgWidth = cornerPoints.getAvgWidth()
      avgHeight = cornerPoints.getAvgHeight()
      avgDiagonalLength = sqr(avgWidth * avgWidth + avgHeight * avgHeight)

      ' maxWidth = cornerPoints.getMaxWidth()
      'maxHeight = cornerPoints.getMaxHeight()

      ' 1. Scale so Avg width & Avg height is correct (eg. aspect ratio is correct), then scale uniformly so longest diagonal is matched
      diagonalLengths = cornerPoints.computeDiagonalLengths()
      longestDiagonal = BGE.Math.Max(diagonalLengths[0], diagonalLengths[1])
      shortestDiagonal = BGE.Math.Min(diagonalLengths[0], diagonalLengths[1])
      useTlBr = false

      if diagonalLengths[1] > (diagonalLengths[0] + 1)
        '        useTlBr = false
      end if



      crossScale = longestDiagonal / avgDiagonalLength

      scaledWidth = avgWidth * crossScale
      scaledHeight = avgHeight * crossScale

      primaryScaleX = scaledWidth / originalWidth
      primaryScaleY = scaledHeight / originalHeight
      scaledDiagonalLength = sqr(scaledWidth * scaledWidth + scaledHeight * scaledHeight)

      scaledDrawX = 0
      scaledDrawY = 0
      if isMirror
        'reverse X, and draw from right side
        primaryScaleX = -primaryScaleX
        scaledDrawX = scaledWidth
      end if

      scaledBitmap = CreateObject("roBitmap", {width: scaledWidth, height: scaledHeight, AlphaEnable: true})
      if invalid = scaledBitmap
        return false
      end if
      scaledRegion = CreateObject("roRegion", scaledBitmap, 0, 0, scaledWidth, scaledHeight)
      m.drawScaledObjectTo(scaledRegion, scaledDrawX, scaledDrawY, primaryScaleX, primaryScaleY, drawable)

      m.addDebugCell(scaledRegion, "scaledRegion")

      ' 2. rotate scaled object so a vertical scale change affects the shorter diagonal only
      aspectRatioAngle = BGE.Math.atan2(scaledHeight, scaledWidth)

      rotation1Bitmap = CreateObject("roBitmap", {width: longestDiagonal, height: longestDiagonal, AlphaEnable: true})
      if invalid = scaledBitmap
        return false
      end if
      rotation1Region = CreateObject("roRegion", rotation1Bitmap, 0, 0, longestDiagonal, longestDiagonal)

      firstRotX = 0
      firstRoty = longestDiagonal / 2
      if not useTlBr
        'scaledRegion.setPretranslation(0, -scaledWidth)
        'firstRotX = longestDiagonal
        'firstRoty = longestDiagonal / 2
        aspectRatioAngle = -aspectRatioAngle
      end if

      m.DrawRotatedObjectTo(rotation1Region, firstRotX, firstRoty, aspectRatioAngle, scaledRegion)

      m.addDebugCell(rotation1Region, "rotation1Region")

      rotation2Bitmap = CreateObject("roBitmap", {width: longestDiagonal, height: longestDiagonal, AlphaEnable: true})
      if invalid = rotation2Bitmap
        return false
      end if
      rotation2Region = CreateObject("roRegion", rotation2Bitmap, 0, 0, longestDiagonal, longestDiagonal)
      shorterDiagScale = shortestDiagonal / scaledDiagonalLength
      longerDiagScale = longestDiagonal / scaledDiagonalLength

      rotatedXScale = longerDiagScale
      rotatedYScale = shorterDiagScale
      vertOffset = (longestDiagonal - shortestDiagonal) / 2
      if not useTlBr
        rotatedXScale = shorterDiagScale
        rotatedYScale = longerDiagScale
      end if
      'rotation2Region.setPretranslation(0, vertOffset)
      m.drawScaledObjectTo(rotation2Region, 0, vertOffset, rotatedXScale, rotatedYScale, rotation1Region)

      'rotation1Region.setPretranslation(0, shortestDiagonal / 2)

      m.addDebugCell(rotation2Region, "rotation2Region")

      '  '   rotation3Bitmap = CreateObject("roBitmap", {width: longestDiagonal, height: longestDiagonal, AlphaEnable: true})
      '     if invalid = rotation3Bitmap
      '       return false
      '     end if
      '     rotation3Region = CreateObject("roRegion", rotation3Bitmap, 0, 0, longestDiagonal, longestDiagonal)
      '     'rotation2Region.setPretranslation(0, -longestDiagonal / 2)
      '     rotatedAspectRatioAngle = BGE.Math.atan2(rotatedYScale, rotatedXScale)
      '    'rotation2Region.setPretranslation(0, longestDiagonal / 2)

      ' m.drawScaledAndRotatedObjectTo(rotation3Region, 0, 0, 1, 1, rotatedAspectRatioAngle, rotation2Region)

      'm.addDebugCell(rotation3Region, "rotation3Region")

      drawOrigin = cornerPoints.topLeft.copy()
      rotationTheta = 0

      if useTlBr
        rotation2Region.setPretranslation(0, -longestDiagonal / 2)

        'topLeft -> bottomRight is longer
        'drawOrigin.y -= longestDiagonal / 2
        rotationTheta = BGE.MATH.GetAngle(cornerPoints.topLeft, cornerPoints.bottomRight)'cornerPoints.getRotationOfTopLeftBottomRightDiagonal(originalDiagonalVector)
        finalTheta = -rotationTheta
      else
        'topRight -> bottomLeft is longer
        ' reverse X
        drawOrigin = cornerPoints.topRight.copy()
        'rotation2Region.setPretranslation(longestDiagonal, -longestDiagonal / 2)

        'rotation2Region.setPretranslation(longestDiagonal, -longestDiagonal / 2)

        rotationTheta = BGE.MATH.GetAngle(cornerPoints.topRight, cornerPoints.bottomLeft)
        finalTheta = rotationTheta '+' BGE.Math.Pi()
      end if


      lineEndX = 300 * cos(rotationTheta) + drawOrigin.x
      lineEndY = 300 * sin(rotationTheta) + drawOrigin.y

      m.drawLine(drawOrigin.x, drawOrigin.y, lineEndX, lineEndY, BGE.Colors().cyan)


      m.DrawRotatedObject(drawOrigin.x, drawOrigin.y, BGE.Math.RadiansToDegrees(finalTheta), rotation2Region)', color)


      return true

      'return m.drawScaledAndRotatedObjectTo(draw2D, cornerPoints.topLeft.x - longestDiagonal / 2, cornerPoints.topLeft.y - shortestDiagonal / 2, 1, 1, finalTheta, rotation1Region, color)
    end function




    function drawCircleOutline(line_count as integer, x as float, y as float, radius as float, rgba as integer) as boolean
      if not m.shouldDraw(x - radius, y - radius, radius * 2, radius * 2)
        return false
      end if

      previous_x = radius
      previous_y = 0
      for i = 0 to line_count
        degrees = 360 * (i / line_count)
        current_x = cos(degrees * .01745329) * radius
        current_y = sin(degrees * .01745329) * radius

        m.draw2d.DrawLine(x + previous_x, y + previous_y, x + current_x, y + current_y, rgba)
        m.drawCallsLastFrame++

        previous_x = current_x
        previous_y = current_y
      end for
      return true
    end function


    function drawRectangleOutline(x as float, y as float, width as float, height as float, rgba as integer) as boolean
      if not m.shouldDraw(x, y, width, height)
        return false
      end if

      m.draw2d.DrawLine(x, y, x + width, y, rgba)
      m.draw2d.DrawLine(x, y, x, y + height, rgba)
      m.draw2d.DrawLine(x + width, y, x + width, y + height, rgba)
      m.draw2d.DrawLine(x, y + height, x + width, y + height, rgba)
      m.drawCallsLastFrame += 4
      return true
    end function

    function drawObject(x as integer, y as integer, src as object) as boolean
      return m.drawObjectTo(m.draw2d, x, y, src)
    end function


    function drawObjectTo(draw2d as object, x as integer, y as integer, src as object) as boolean
      if not m.shouldDrawTo(draw2d, x, y, src.getWidth(), src.getHeight())
        return false
      end if
      draw2d.drawObject(x, y, src)
      drawCallsLastFrame++
      return true
    end function


    function drawScaledObject(x as integer, y as integer, scaleX as float, scaleY as float, src as object) as boolean
      return m.drawScaledObjectTo(m.draw2d, x, y, scaleX, scaleY, src)
    end function

    function drawScaledObjectTo(draw2d as object, x as integer, y as integer, scaleX as float, scaleY as float, src as object) as boolean
      if not m.shouldDrawTo(draw2d, x, y, src.getWidth() * scaleX, src.getHeight() * scaleY)
        return false
      end if
      draw2d.DrawScaledObject(x, y, scaleX, scaleY, src)
      m.drawCallsLastFrame++
      return true
    end function

    function drawRotatedObject(x as integer, y as integer, theta as float, src as object) as boolean
      return m.drawRotatedObjectTo(m.draw2d, x, y, theta, src)
    end function

    function drawRotatedObjectTo(draw2d as object, x as integer, y as integer, theta as float, src as object) as boolean
      if not m.shouldDrawTo(draw2d, x, y, src.getWidth(), src.getHeight(), theta)
        return false
      end if
      thetaDeg = BGe.Math.RadiansToDegrees(theta)
      draw2d.DrawRotatedObject(x, y, thetaDeg, src)
      m.drawCallsLastFrame++
      return true
    end function

    function drawRegionToCanvas(regionToDraw as object, canvasDrawTo as object, x as float, y as float, scaleX = 1 as float, scaleY = 1 as float, rotation = 0 as float, RGBA = -1 as integer) as void

      if scaleX = 1 and scaleY = 1 and rotation = 0
        m.DrawObjectTo(canvasDrawTo, x, y, regionToDraw)
      else if rotation = 0
        m.DrawScaledObjectTo(canvasDrawTo, x, y, scaleX, scaleY, regionToDraw)
      else if scaleX = 1 and scaleY = 1
        m.DrawRotatedObjectTo(canvasDrawTo, x, y, -rotation, regionToDraw)
      else
        m.DrawScaledAndRotatedObjectTo(canvasDrawTo, x, y, scaleX, scaleY, -rotation, regionToDraw, rgba)
      end if
    end function


    private function shouldDraw(x as float, y as float, width as float, height as float, rotation = 0 as float) as boolean
      return m.shouldDrawTo(m.draw2d, x, y, width, height, rotation)
    end function

    private function shouldDrawTo(draw2d as object, x as float, y as float, width as float, height as float, rotation = 0 as float) as boolean
      if not m.onlyDrawWhenInFrame
        return true
      end if
      return m.isInsideCanvas(draw2d, x, y, width, height, rotation)
    end function


    ' Checks to see if a rectangle will be in a Draw2d Canvas
    '
    ' @param {object} draw2d
    ' @param {float} x
    ' @param {float} y
    ' @param {float} width
    ' @param {float} height
    ' @return {boolean} true if this rectangle overlaps with the canvas
    function isInsideCanvas(draw2d as object, x as float, y as float, width as float, height as float, rotation = 0 as float) as boolean
      canvasWidth = draw2d.getWidth()
      canvasHeight = draw2d.getHeight()
      if rotation <> 0
        ' use diagonal as radius for seeing were rotated points could be
        ' this gives a bigger approximation for rotated objects, but is easier
        radius = Sqr(width * width + height * height)
        x = BGE.Math.Min(x, x + cos(rotation) * radius)
        y = BGE.Math.Min(y, y + sin(rotation) * radius)
        width = radius
        height = radius
      end if
      ' check each corner
      corners = [
        {x: x, y: y},
        {x: x + width, y: y},
        {x: x, y: y + height},
        {x: x + width, y: y + height}
      ]
      insideCanvas = false
      for each point in corners
        if x >= 0 and x <= canvasWidth and y >= 0 and y <= canvasHeight
          ' if one corner is in then this will be drawn
          insideCanvas = true
          exit for
        end if
      end for
      ' no corner is in the canvas, but this whole thing could overlap somehow
      if not insideCanvas and x < 0 and (x + width) > canvasWidth
        if y < 0
          insideCanvas = (y + height) >= 0
        else if y <= canvasHeight
          insideCanvas = true
        end if
      end if
      if not insideCanvas and y < 0 and (y + height) > canvasHeight
        if x < 0
          insideCanvas = (x + width) >= 0
        else if x <= canvasWidth
          insideCanvas = true
        end if
      end if

      return insideCanvas
    end function

    sub addDebugCell(region as object, text = "" as string)
      regionWidth = region.getWidth()
      regionHeight = region.getHeight()
      scale = m.debugCellSize - 2
      offsetX = 1
      offsetY = 1
      if regionWidth > regionHeight
        scale = scale / regionWidth
        offsetY = m.debugCellSize / 2 - scale * regionHeight / 2 + 1
      else
        scale = scale / regionHeight
        offsetX = m.debugCellSize / 2 - scale * regionWidth / 2 + 1
      end if
      cellX = m.debugCellStart.x + m.debugCellSize * m.activeDebugCells
      cellY = m.debugCellStart.y
      textY = cellY + m.debugCellSize + 2
      m.drawRectangleOutline(cellX, cellY, m.debugCellSize, m.debugCellSize, BGE.Colors().White)
      m.drawRegionToCanvas(region, m.draw2d, cellX + offsetX, cellY + offsetY, scale, scale)
      debugText = `(${cint(regionWidth)}, ${cint(regionHeight)})`
      m.drawText(text, cellX, textY, m.game.getFont("debugUiSmall"))
      m.drawText(debugText, cellX, textY + 12, m.game.getFont("debugUiSmall"))
      m.activeDebugCells++
    end sub

  end class

end namespace
