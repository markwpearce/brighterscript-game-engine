namespace BGE

  ' Wrapper for Draw2D calls, so that we can keep track of how much is being drawn per frame
  class Renderer

    nextSceneObjectId = 0
    ' Frame rate target - the game will reduce quality if this target is not met
    protected minimumFrameRateTarget as integer = 12

    protected onlyDrawWhenInFrame as boolean = true

    private drawCallsLastFrame = 0
    private activeDebugCells = 0
    private debugCellSize = 100
    private debugCellStart as BGE.Math.Vector = BGE.Math.VectorOps.create(100, 100)
    drawDebugCells = false

    private draw2d as ifDraw2D = invalid

    private sceneObjects as SceneObject[] = []

    camera as Camera

    triangleCache = new TriangleCache(30)

    game as Game

    'private maxBitmapWidth = 1920'1280
    'private maxBitmapHeight = 1080'720

    frameCount = 0

    private bmpPool = new BGE.ScratchBitmapPool()

    sub new(mainGame as BGE.Game, draw2d as ifDraw2d, cam = invalid as BGE.Camera)
      m.game = mainGame
      m.draw2d = draw2d
      if invalid = cam
        cam = new Camera2d()
        cam.setFrameSize(m.draw2d.getWidth(), m.draw2d.getHeight())
        cam.useDefaultCameraTarget()
      end if
      m.camera = cam
    end sub

    sub setDraw2d(draw2d as ifDraw2d)
      m.draw2d = draw2d
      m.camera.setFrameSize(m.draw2d.getWidth(), m.draw2d.getHeight())
    end sub

    sub resetDrawCallCounter()
      m.drawCallsLastFrame = 0
      m.activeDebugCells = 0
    end sub


    sub addSceneObject(sceneObj as SceneObject)
      sceneObj.setId(m.nextSceneObjectId.toStr().trim())
      m.nextSceneObjectId++
      m.sceneObjects.push(sceneObj)
    end sub

    sub removeSceneObject(sceneObj as SceneObject)
      indexToDelete = -1
      for i = 0 to m.sceneObjects.count()
        if m.sceneObjects[i].id = sceneObj.id
          indexToDelete = i
          exit for
        end if
      end for
      if indexToDelete >= 0
        m.sceneObjects.delete(indexToDelete)
      end if
      sceneObj.id = ""
    end sub

    private sub updateSceneObjects()
      for each sceneObj in m.sceneObjects
        if sceneObj.isEnabled()
          sceneObj.update(m.camera)
        end if
      end for
    end sub

    sub setupCameraForFrame()
      m.camera.setFrameSize(m.draw2d.getWidth(), m.draw2d.getHeight())
      m.camera.checkMovement()

      if m.camera.movedLastFrame() or invalid = m.camera.worldToCamera
        m.camera.computeWorldToCameraMatrix()
      end if
    end sub

    sub drawScene()
      m.updateSceneObjects()

      m.sceneObjects.sortBy("negDistanceFromCamera")

      ' draw sceneObjects in sorted order
      ' ignore any that are too far away (TBD) or behind camera
      for each sceneObj in m.sceneObjects
        if sceneObj.isEnabled()
          if sceneObj.negDistanceFromCamera < 0 'and sceneObj.normnegDistanceFromCamera < 10000
            sceneObj.draw(m)
          end if
        end if
      end for
    end sub


    sub onSwapBuffers()
      m.frameCount++
      if m.frameCount = 30
        ? `Draw Calls: ${m.drawCallsLastFrame} | Scene Objects: ${m.sceneObjects.count()}`
        m.frameCount = 0
      end if

    end sub

    function worldPointToCanvasPoint(pWorld as BGE.Math.Vector) as BGE.Math.Vector
      return m.camera.worldPointToCanvasPoint(pWorld)
    end function

    function getRayFromCameraToWorldPoint(pWorld as BGE.Math.Vector) as BGE.Math.Vector
      return BGE.Math.VectorOps.subtract(pWorld, m.camera.position)
    end function

    function drawLine(x as float, y as float, endX as float, endY as float, rgba as integer) as boolean
      return m.drawLineTo(m.draw2d, x, y, endX, endY, rgba)
    end function

    function drawLineTo(draw2d as ifDraw2d, x as float, y as float, endX as float, endY as float, rgba as integer) as boolean
      width = abs(x - endx) + 1
      height = abs(y - endY) + 1
      if not m.shouldDrawTo(draw2D, x, y, width, height)
        return false
      end if
      draw2d.DrawLine(x, y, endX, endY, rgba)
      m.drawCallsLastFrame++
      return true
    end function


    function drawSquare(x as float, y as float, sideLength as float, rgba as integer) as boolean
      return m.drawSquareTo(m.draw2d, x, y, sideLength, rgba)
    end function

    function drawSquareTo(draw2d as ifDraw2d, x as float, y as float, sideLength as float, rgba as integer) as boolean
      if not m.shouldDrawTo(draw2D, x - sideLength / 2, y - sideLength / 2, sideLength, sideLength)
        return false
      end if
      draw2d.DrawPoint(x, y, sideLength, rgba)
      m.drawCallsLastFrame++
      return true
    end function

    function drawRectangle(x as float, y as float, width as float, height as float, rgba as integer) as boolean
      return m.drawRectangleTo(m.draw2d, x, y, width, height, rgba)
    end function

    function drawRectangleTo(draw2d as ifDraw2d, x as float, y as float, width as float, height as float, rgba as integer) as boolean
      if not m.shouldDrawTo(draw2D, x, y, width, height)
        return false
      end if
      draw2d.DrawRect(x, y, width, height, rgba)
      m.drawCallsLastFrame++
      return true
    end function

    ' Draws text to the screen
    '
    ' @param {string} text the test to display
    ' @param {integer} x
    ' @param {integer} y
    ' @param {integer} [color=-1] RGBA color to use
    ' @param {roFont} [font=invalid] Font object to use (uses default font if none provided)
    ' @param {string} [horizAlign="left"] Horizontal Alignment - "left", "right" or "center"
    ' @param {string} [vertAlign="left"] Vertical Alignment - "top", "bottom" or "center"
    function drawText(text as string, x as integer, y as integer, color = -1 as integer, font = invalid as roFont, horizAlign = "left" as string, vertAlign = "top" as string) as boolean
      return m.drawTextTo(m.draw2d, text, x, y, color, font, horizAlign, vertAlign)
    end function


    ' Draws text to a canvas
    '
    ' @param {string} text the test to display
    ' @param {integer} x
    ' @param {integer} y
    ' @param {integer} [color=-1] RGBA color to use
    ' @param {roFont} [font=invalid] Font object to use (uses default font if none provided)
    ' @param {string} [horizAlign="left"] Horizontal Alignment - "left", "right" or "center"
    ' @param {string} [vertAlign="left"] Vertical Alignment - "top", "bottom" or "center"
    function drawTextTo(draw2d as ifDraw2d, text as string, x as integer, y as integer, color = -1 as integer, font = invalid as roFont, horizAlign = "left" as string, vertAlign = "top" as string) as boolean
      if font = invalid
        font = m.game.getFont("default")
      end if

      width = font.GetOneLineWidth(text, 10000)
      height = font.GetOneLineHeight() * BGE.getNumberOfLinesInAString(text)
      textX = x
      textY = y

      if horizAlign = "right"
        textX = x - width
      else if horizAlign = "center"
        textX = x - width / 2
      end if

      if vertAlign = "bottom"
        textY = y - height
      else if vertAlign = "center"
        textY = y - height / 2
      end if
      if m.shouldDrawTo(draw2D, textX, textY, width, height)
        draw2d.DrawText(text, textX, textY, color, font)
        m.drawCallsLastFrame++
        return true
      end if
      return false
    end function

    ' NOTE: This function is unsafe! It creates an roBitmap of the required size to be able to both scale and rotate the drawing, this action requires free video memory of the appropriate amount.
    function drawTransformedObject(x as float, y as float, scaleX as float, scaleY as float, theta as float, region as ifDraw2d, rgba = -1 as integer) as boolean
      return m.drawTransformedObjectTo(m.draw2d, x, y, scaleX, scaleY, theta, region, rgba)
    end function

    function drawTransformedObjectTo(draw2d as ifDraw2d, x as float, y as float, scale_x as float, scale_y as float, theta as float, region as ifDraw2d, rgba = -1 as integer) as boolean
      thetaDeg = BGE.Math.RadiansToDegrees(theta)
      ' using undocumented ifDraw2d function
      result = (draw2d as dynamic).DrawTransformedObject(x, y, thetaDeg, scale_x, scale_y, region, rgba)
      m.drawCallsLastFrame++
      return result
    end function

    function drawPinnedCorners(cornerPoints as BGE.Math.CornerPoints, drawableRegion as RegionWithId, isMirror = false as boolean, color = -1 as integer) as boolean
      return m.drawPinnedCornersTo(m.draw2d, cornerPoints, drawableRegion, isMirror, color)
    end function


    function drawRotatedImageWithCenterTo(draw2d as ifDraw2d, srcRegion as ifDraw2d, center as BGE.Math.Vector, theta as float, translation = BGE.Math.VectorOps.create() as BGE.Math.Vector, drawScale = BGE.Math.createScaleVector(1)) as boolean
      distanceToCenter = BGE.Math.VectorOps.length(center)
      angleToCenter = BGE.Math.GetAngle(BGE.Math.VectorOps.create(), center)
      centerRotationAngle = theta - angleToCenter
      rotatedCenter = BGE.Math.VectorOps.create(distanceToCenter * cos(centerRotationAngle), -distanceToCenter * sin(centerRotationAngle))
      finalTranslation = BGE.Math.VectorOps.add(translation, BGE.Math.VectorOps.subtract(center, rotatedCenter))

      if drawScale.x = 1 and drawScale.y = 1
        return m.drawRotatedObjectTo(draw2D, finalTranslation.x, finalTranslation.y, theta, srcRegion)
      end if
      return m.drawTransformedObjectTo(draw2d, finalTranslation.x, finalTranslation.y, drawScale.x, drawScale.y, theta, srcRegion)
    end function


    function makeIntoTriangle(srcRegionWithId as RegionWithId, points as BGE.Math.Vector[], makeAcute = false, useCache = false) as TriangleBitmap
      if useCache
        existingItem = m.triangleCache.getTriangle(srcRegionWithId.id, points)
        if invalid <> existingItem
          return existingItem
        end if
      end if

      if points.count() < 3
        return invalid
      end if

      srcRegion = srcRegionWithId.region

      srcPreX = 0
      srcPreY = 0

      srcRegion.GetPretranslationX()
      srcRegion.GetPretranslationY()
      scratchRegion1 = invalid
      if srcPreX <> 0 or srcPreY <> 0
        m.addDebugCell(srcRegion, "srcRegionPreTran")
        scratchRegion1 = m.bmpPool.getRegion(srcRegion.getWidth(), srcRegion.getHeight())
        if invalid = scratchRegion1
          return invalid
        end if

        unPreTranslated = scratchRegion1.region
        if not m.drawObjectTo(unPreTranslated, -srcPreX, -srcPreY, srcRegion)
          m.bmpPool.returnRegions([scratchRegion1])
          return invalid
        end if
        srcRegion = unPreTranslated
      end if

      canGetPoints = true
      for i = 0 to 2
        canGetPoints = canGetPoints and m.isInsideCanvas(srcRegion, points[i].x, points[i].y, 1, 1, 0)
        if not canGetPoints
          exit for
        end if
      end for
      if not canGetPoints
        m.bmpPool.returnRegions([scratchRegion1])
        return invalid
      end if
      srcTri = new BGE.Math.Triangle(points, false)

      m.addDebugCell(srcRegion, "srcRegion")

      halfPi = BGE.Math.halfPI()
      longestIndex = srcTri.longestIndex
      startIndex = srcTri.nextIndex(longestIndex)
      longestSide = srcTri.getLongestSide()
      bmpSizeW = longestSide
      bmpSizeH = longestSide

      originPoint = srcTri.points[startIndex]

      scratchRegion2 = m.bmpPool.getRegion(bmpSizeW, bmpSizeH)
      if invalid = scratchRegion2
        m.bmpPool.returnRegions([scratchRegion1])
        return invalid
      end if
      initialRegion = scratchRegion2.region

      initialAngle = srcTri.anglesToPrevious[startIndex]
      initialCenter = BGE.Math.VectorOps.negative(originPoint)
      m.drawRotatedImageWithCenterTo(initialRegion, srcRegion, originPoint, initialAngle, initialCenter, scratchRegion2.scale)

      m.addDebugCell(initialRegion, "initialRegion")

      ' At this point, we have region where the top line is the longest side of the triangle
      ' find the angle to rotate to cut off the right side
      prevIndex = srcTri.previousIndex(startIndex)
      rightSideTheta = -initialAngle - halfPi + srcTri.anglesToPrevious[prevIndex]

      scratchRegion3 = m.bmpPool.getRegion(bmpSizeW, bmpSizeH, true)
      if invalid = scratchRegion3
        m.bmpPool.returnRegions([scratchRegion1, scratchRegion2])
        return invalid
      end if

      region2 = scratchRegion3.region

      m.drawRotatedImageWithCenterTo(region2, initialRegion, BGE.Math.VectorOps.create(bmpSizeW, 0), rightSideTheta)

      m.addDebugCell(region2, "region2")
      bitmap3 = invalid
      region3 = invalid as roRegion
      scratchRegion4 = invalid as BGE.ScratchRegion
      if useCache
        bitmap3 = CreateObject("roBitmap", {width: fix(bmpSizeW + 1), height: fix(bmpSizeH + 1), AlphaEnable: true})
        region3 = CreateObject("roRegion", bitmap3, 0, 0, bmpSizeW, bmpSizeW)
      else
        scratchRegion4 = m.bmpPool.getRegion(bmpSizeW, bmpSizeH)
        if invalid = scratchRegion4
          m.bmpPool.returnRegions([scratchRegion1, scratchRegion2, scratchRegion3])
          return invalid
        end if
        region3 = scratchRegion4.region
      end if

      if invalid = region3
        m.bmpPool.returnRegions([scratchRegion1, scratchRegion2, scratchRegion3])
        return invalid
      end if
      ' region3 = scratchRegion4.region
      region3.SetScaleMode(1)
      prevIndex = srcTri.previousIndex(prevIndex)

      lastRotCenter = BGE.Math.VectorOps.create(longestSide - longestSide * cos(rightSideTheta), longestSide * sin(rightSideTheta))
      leftSideTheta = -srcTri.angles[prevIndex]
      m.drawRotatedImageWithCenterTo(region3, region2, lastRotCenter, leftSideTheta, BGE.Math.VectorOps.negative(lastRotCenter))

      resultPoints = [BGE.Math.VectorOps.create(), BGE.Math.VectorOps.create(), BGE.Math.VectorOps.create()]

      ' next point is always mapped to (0,0)
      index = (longestIndex + 1) mod 3
      resultPoints[index].x = 0
      resultPoints[index].y = 0

      ' prevPoint is always on the y-axis
      nextLength = srcTri.lengths[index]
      index = (index + 1) mod 3
      resultPoints[index].y = nextLength ' prevpoint is where the next leg ends

      ' last point(longestPoint) is found via trig
      index = longestIndex

      finalAngle = srcTri.angles[(longestIndex + 1) mod 3]
      resultPoints[index].x = fix(longestSide * cos(halfPi - finalAngle))
      resultPoints[index].y = fix(longestSide * sin(halfPi - finalAngle))

      'm.drawTrianglePointsTo(region3, resultPoints)

      result = new TriangleBitmap(region3, resultPoints)
      if not useCache
        result.scratchRegion = scratchRegion4
      end if
      result.angleRotatedFromOriginal = BGE.Math.halfPi() - srcTri.anglesToNext[srcTri.nextIndex(longestIndex)]
      m.addDebugCell(region3, "triangle")

      if not result.isAcute() and makeAcute
        ' Make the cached triangles Acute, so it is easier to transform them into obtuse triangles later
        result = m.scaleTriangleToBeAcuteTriangle(result)
        if result = invalid
          m.bmpPool.returnRegions([scratchRegion1, scratchRegion2, scratchRegion3])
          return invalid
        end if
        m.addDebugCell(result.bitmap, "acuteTriangle")
      end if
      if useCache
        m.triangleCache.addTriangle(srcRegionWithId.id, points, result)
      end if
      m.bmpPool.returnRegions([scratchRegion1, scratchRegion2, scratchRegion3])', scratchRegion4])
      return result
    end function

    function drawBitmapTriangleTo(draw2d as ifDraw2d, srcRegionWithId as RegionWithId, srcPoints as BGE.Math.Vector[], destPoints as BGE.Math.Vector[]) as boolean
      if srcPoints.count() < 3 or destPoints.count() < 3
        return false
      end if
      shouldDraw = false
      for i = 0 to 2
        shouldDraw = shouldDraw or m.shouldDrawTo(draw2d, destPoints[i].x, destPoints[i].y, 1, 1, 0)
        if shouldDraw
          exit for
        end if
      end for
      if not shouldDraw
        return false
      end if

      srcTriangle = m.makeIntoTriangle(srcRegionWithId, srcPoints, true, true) as BGE.TriangleBitmap
      srcRegion = srcRegionWithId.region
      if invalid = srcTriangle
        return false
      end if

      destTriangle = new BGE.Math.Triangle(destPoints)
      srcOriginIndex = srcTriangle.getOriginIndex()

      if srcOriginIndex <> destTriangle.nextIndex(destTriangle.longestIndex) and destTriangle.isObtuse()
        'rearrange srcTriangle so side that corresponds to dest's longest side is on top of a bitmap
        srcTriangle = m.rotateAcuteTriangleForDesiredOrigin(srcTriangle, destTriangle.nextIndex(destTriangle.longestIndex))
      end if

      if invalid = srcTriangle
        return false
      end if

      pivotIndex = srcTriangle.previousIndex(srcTriangle.getOriginIndex())

      nextIndex = srcTriangle.nextIndex(pivotIndex)
      prevIndex = srcTriangle.nextIndex(nextIndex)


      finalBitmapWidth = destTriangle.getLongestSide() * 1.33
      finalBitmapHeight = finalBitmapWidth

      mappedLongestLength = destTriangle.lengths[pivotIndex]
      mappedPreviousLength = destTriangle.lengths[prevIndex]
      mappedNextLength = destTriangle.lengths[nextIndex]

      srcScales = m.getScalesForTriangleMapping(srcTriangle, destTriangle)
      srcXScale = srcScales.x
      srcYScale = srcScales.y

      srcPivot = srcTriangle.points[pivotIndex]
      mappedOriginPointAfterLengthSet = BGE.Math.VectorOps.create(srcPivot.x * srcXScale, srcPivot.y * srcYScale)
      changedPointOnYAxis = BGE.Math.VectorOps.copy(srcTriangle.points[prevIndex])
      changedPointOnYAxis.y *= srcYScale

      angleToMappedLongest = BGE.Math.GetAngle(BGE.Math.VectorOps.create(), mappedOriginPointAfterLengthSet)
      distanceToMappedLongest = BGE.Math.VectorOps.length(mappedOriginPointAfterLengthSet)
      newHeightAfterChange = changedPointOnYAxis.y

      scratchRegion1 = m.bmpPool.getRegion(distanceToMappedLongest, newHeightAfterChange)
      if invalid = scratchRegion1
        m.bmpPool.returnRegions([scratchRegion1])
        return false
      end if

      scaledSrcRegion = scratchRegion1.region

      ' Update the distances here to be based on what is actually allowed with scratch bitmaps
      scaleDueToScratchBitmapSize = scratchRegion1.scale
      distanceToMappedLongest = BGE.Math.min(distanceToMappedLongest, scaledSrcRegion.GetWidth())
      newHeightAfterChange = BGE.Math.min(newHeightAfterChange, scaledSrcRegion.GetHeight())

      m.drawScaledObjectTo(scaledSrcRegion, 0, 0, srcXScale * scratchRegion1.scale.x, srcYScale * scratchRegion1.scale.y, srcTriangle.bitmap)

      m.drawTrianglePointsTo(scaledSrcRegion, [
        BGE.Math.VectorOps.create(),
        BGE.Math.VectorOps.create(0, newHeightAfterChange), ' was changedPointOnYAxis, but this is not safe - could be too big
        mappedOriginPointAfterLengthSet
      ])

      m.addDebugCell(scaledSrcRegion, "scaledSrcRegion")

      destOrigin = destTriangle.points[nextIndex]

      finalAngle = BGE.Math.GetAngle(destOrigin, destTriangle.points[pivotIndex])
      rotatedTriHeight = newHeightAfterChange * cos(angleToMappedLongest)

      rotatedRegionHeight = rotatedTriHeight

      scratchRegion2 = m.bmpPool.getRegion(distanceToMappedLongest, rotatedRegionHeight)
      if invalid = scratchRegion2
        m.bmpPool.returnRegions([scratchRegion1, scratchRegion2])
        return false
      end if

      rotatedRegion = scratchRegion2.region

      angleToMappedLongest = Bge.Math.Max(angleToMappedLongest, 0.05)

      m.drawRotatedObjectTo(rotatedRegion, 0, 0, angleToMappedLongest, scaledSrcRegion)

      m.addDebugCell(rotatedRegion, "rotatedRegion")
      firstPartLength = BGE.Math.Max(changedPointOnYAxis.y * sin(angleToMappedLongest), 0)

      secondPartLength = distanceToMappedLongest - firstPartLength

      firstPartRegion = CreateObject("roRegion", scratchRegion2.getBitmapObject(), 0, 0, firstPartLength, rotatedTriHeight)

      if invalid = firstPartRegion
        m.bmpPool.returnRegions([scratchRegion1, scratchRegion2])
        return false
      end if
      firstPartRegion.SetScaleMode(1)

      secondPartRegion = CreateObject("roRegion", scratchRegion2.getBitmapObject(), BGE.Math.Max(0, firstPartLength - 1), 0, secondPartLength, rotatedTriHeight)
      if invalid = secondPartRegion
        m.bmpPool.returnRegions([scratchRegion1, scratchRegion2])
        return false
      end if
      secondPartRegion.SetScaleMode(1)
      destFirstPartWidth = mappedNextLength * cos(destTriangle.angles[nextIndex])
      destSecondPartWidth = mappedLongestLength - destFirstPartWidth

      firstPartScaleX = 0
      if firstPartLength > 0
        firstPartScaleX = destFirstPartWidth / firstPartLength
      end if

      secondPartScaleX = 0
      if secondPartLength > 0
        secondPartScaleX = destSecondPartWidth / secondPartLength
      end if
      if rotatedTriHeight = 0
        m.bmpPool.returnRegions([scratchRegion1, scratchRegion2])
        return false
      end if

      finalScaleY = destTriangle.getHeightByTangentIndex(nextIndex) / rotatedTriHeight

      scratchRegion3 = m.bmpPool.getRegion(finalBitmapWidth, finalBitmapHeight)
      if invalid = scratchRegion3 or scratchRegion3.region = invalid
        m.bmpPool.returnRegions([scratchRegion1, scratchRegion2])
        return false
      end if

      finalRegion = scratchRegion3.region

      m.addDebugCell(firstPartRegion, "firstPartRegion")

      m.addDebugCell(secondPartRegion, "secondPartRegion")

      finalRegion.SetScaleMode(1)
      didDraw = true
      if firstPartScaleX <> 0
        didDraw = m.DrawScaledObjectTo(finalRegion, 0, 0, firstPartScaleX * 1.01, finalScaleY * 1.01, firstPartRegion)
      end if
      if didDraw and invalid <> secondPartRegion
        didDraw = m.DrawScaledObjectTo(finalRegion, destFirstPartWidth - 1, 0, secondPartScaleX * 1.01, finalScaleY * 1.01, secondPartRegion)
      end if

      m.addDebugCell(finalRegion, "finalRegion")
      scalesAreNonZero = (scaleDueToScratchBitmapSize.x <> 0) and (srcTriangle.scale.x <> 0) and (scaleDueToScratchBitmapSize.y <> 0) and (srcTriangle.scale.y <> 0)
      if didDraw and scalesAreNonZero
        didDraw = m.drawTransformedObjectTo(draw2d, destOrigin.x, destOrigin.y, 1 / (scaleDueToScratchBitmapSize.x * srcTriangle.scale.x), 1 / (scaleDueToScratchBitmapSize.y * srcTriangle.scale.y), -finalAngle, finalRegion)
      else
        didDraw = false
      end if
      m.bmpPool.returnRegions([scratchRegion1, scratchRegion2, scratchRegion3])
      return didDraw
    end function

    private function getScalesForTriangleMapping(srcTriangle as BGE.Math.Triangle, destTriangle as BGE.Math.Triangle) as BGE.Math.Vector

      srcXScale = 1
      srcYScale = 1
      foundXScale = false

      pivotIndex = srcTriangle.previousIndex(srcTriangle.getOriginIndex())

      nextIndex = srcTriangle.nextIndex(pivotIndex)
      prevIndex = srcTriangle.nextIndex(nextIndex)
      mappedLongestLength = destTriangle.lengths[pivotIndex]
      mappedPreviousLength = destTriangle.lengths[prevIndex]
      mappedNextLength = destTriangle.lengths[nextIndex]

      srcLongestLength = srcTriangle.lengths[pivotIndex]
      srcPreviousLength = srcTriangle.lengths[prevIndex]
      srcNextLength = srcTriangle.lengths[nextIndex]

      srcOriginPointX = srcTriangle.points[pivotIndex].x

      destFirstPartWidth = mappedNextLength * cos(destTriangle.angles[nextIndex])
      destSecondPartWidth = mappedLongestLength - destFirstPartWidth
      if (destSecondPartWidth > 0) and (destFirstPartWidth > 0)
        k = destFirstPartWidth / destSecondPartWidth
        y = srcNextLength
        y1 = srcTriangle.points[pivotIndex].y
        y2 = y - y1

        insideSqr = ((y * y + y1 * y1 - y2 * y2) / (2 * k * k + 2 * k))

        if insideSqr > 0
          beta = sqr(insideSqr)
          alpha = beta * k
          c = alpha + beta
          insideSqr2 = c * c - y1 * y1
          if insideSqr2 > 0
            whereSrcOriginPointXNeedsToBe = sqr(insideSqr2)

            whereSrcOriginPointXNeedsToBe = BGE.Math.min(whereSrcOriginPointXNeedsToBe, 10 * mappedLongestLength)
            foundXScale = true
          end if
        end if
      end if

      if not foundXScale
        srcYScale = mappedNextLength / srcTriangle.lengths[nextIndex]
        srcPointOnYAxis = srcTriangle.points[prevIndex]
        changedPointOnYAxis = BGE.Math.VectorOps.copy(srcPointOnYAxis)
        changedPointOnYAxis.y *= srcYScale
        changedPointOnYAxisYDelta = mappedNextLength - srcTriangle.lengths[nextIndex]
        srcOriginPointYAfterScale = srcTriangle.points[pivotIndex].y * srcYScale
      end if
      if not foundXScale
        ' Scale so yAxis edge and bottom edge are correct length for dest
        pythagorasLeg = mappedNextLength - srcOriginPointYAfterScale
        insideSqrForLegs = mappedPreviousLength * mappedPreviousLength - pythagorasLeg * pythagorasLeg
        if insideSqrForLegs > 0
          whereSrcOriginPointXNeedsToBe = sqr(insideSqrForLegs)
          checkLength = whereSrcOriginPointXNeedsToBe * whereSrcOriginPointXNeedsToBe - srcOriginPointYAfterScale * srcOriginPointYAfterScale
          if checkLength > 0
            foundXScale = true
          end if
        end if
      end if

      if not foundXScale
        'make angle at origin the same as the "nextAngle" of destTri
        whereSrcOriginPointXNeedsToBe = srcOriginPointYAfterScale * tan(destTriangle.angles[nextIndex])
        checkLength = whereSrcOriginPointXNeedsToBe * whereSrcOriginPointXNeedsToBe - srcOriginPointYAfterScale * srcOriginPointYAfterScale
        if checklength > 0
          foundXScale = true
        end if
      end if

      if not foundXScale
        ' Scale so yAxis edge and top edge are correct length for dest
        insideSqrForTopSide = mappedLongestLength * mappedLongestLength - srcOriginPointYAfterScale * srcOriginPointYAfterScale
        if insideSqrForTopSide > 0
          whereSrcOriginPointXNeedsToBe = sqr(insideSqrForTopSide)
          foundXScale = true
        end if
      end if

      if not foundXScale
        ' Scale so point's x is equal to dest longest length
        whereSrcOriginPointXNeedsToBe = mappedLongestLength
        foundXScale = true
      end if


      if srcOriginPointX <> 0
        srcXScale = whereSrcOriginPointXNeedsToBe / srcOriginPointX
      end if
      return BGE.Math.VectorOps.create(srcXScale, srcYScale)
    end function


    ' There can be problems transforming a source triangle to a destination triangle when they are obtuse and the longest sides don't match up
    ' This function will scale a source triangle along the axis of its longest side so that it is an acute-triangle
    private function scaleTriangleToBeAcuteTriangle(srcTriangle as TriangleBitmap) as TriangleBitmap
      pivotIndex = srcTriangle.previousIndex(srcTriangle.getOriginIndex())
      nextIndex = srcTriangle.nextIndex(pivotIndex)
      prevIndex = srcTriangle.nextIndex(nextIndex)

      pointA = srcTriangle.points[pivotIndex]
      pointB = srcTriangle.points[nextIndex]
      pointC = srcTriangle.points[prevIndex]

      srcLongestLength = srcTriangle.getLongestSide()
      srcNextLength = srcTriangle.lengths[nextIndex]
      srcPrevLength = srcTriangle.lengths[prevIndex]

      firstRotation = srcTriangle.anglesToPrevious[nextIndex]


      'rotatedSrcBitmap = CreateObject("roBitmap", {width: srcLongestLength, height: srcLongestLength, AlphaEnable: true})
      'rotatedSrcRegion = CreateObject("roRegion", rotatedSrcBitmap, 0, 0, finalBitmapWidth, finalBitmapHeight)

      scratchRegion1 = m.bmpPool.getRegion(srcLongestLength, srcLongestLength)
      if invalid = scratchRegion1
        return invalid
      end if

      rotatedSrcRegion = scratchRegion1.region

      m.drawRotatedObjectTo(rotatedSrcRegion, 0, 0, firstRotation, srcTriangle.bitmap)

      newPrevPointY = srcNextLength * cos(firstRotation)
      newPrevPointX = srcNextLength * sin(firstRotation)

      m.addDebugCell(rotatedSrcRegion, "rotatedSrcRegion")


      ' Scaling from Y-axis will mean the ratio between triangle legs will be constant
      ' So we can set that ratio equal to tan(newNextAngle) and use atn() to get newNextAngle
      ' Once We know newNextAngle, we can use its complement to find the distance of the acuteAngle of the scaled triangle
      ' from the y-axis
      ' And from that, get the scale

      ratio = srcPrevLength / srcNextLength
      newNextAngle = atn(ratio)

      scaleYToMakeAcute = 1.2
      bottomYForRightTriangle = srcNextLength / sin(newNextAngle)

      ' = srcTriangle.height * tan(BGE.Math.halfPI() - newNextAngle)

      acuteNextY = scaleYToMakeAcute * bottomYForRightTriangle

      scaleY = acuteNextY / newPrevPointY

      newSrcLongest = srcLongestLength
      newNextLength = sqr(newPrevPointX * newPrevPointX + acuteNextY * acuteNextY)
      newBitmapSize = BGE.Math.Max(srcLongestLength * scaleYToMakeAcute, newNextLength)

      'acuteTriBitmap = CreateObject("roBitmap", {width: newBitmapSize, height: newBitmapSize, AlphaEnable: true})
      '  acuteTriangleSrcRegion = CreateObject("roRegion", rotatedSrcBitmap, 0, 0, finalBitmapWidth, finalBitmapHeight)

      scratchRegion2 = m.bmpPool.getRegion(newBitmapSize, newBitmapSize)
      if invalid = scratchRegion2
        m.bmpPool.returnRegions([scratchRegion1, scratchRegion2])
        return invalid
      end if

      acuteTriRegion = scratchRegion2.region

      m.drawScaledObjectTo(acuteTriRegion, 0, 0, 1, scaleY, rotatedSrcRegion)

      m.addDebugCell(acuteTriRegion, "acuteTriRegion")


      acuteTriRotBmp = CreateObject("roBitmap", {width: newBitmapSize, height: newBitmapSize, AlphaEnable: true})
      '  acuteTriangleSrcRegion = CreateObject("roRegion", rotatedSrcBitmap, 0, 0, finalBitmapWidth, finalBitmapHeight)
      if invalid = acuteTriRotBmp
        m.bmpPool.returnRegions([scratchRegion1, scratchRegion2])
        return invalid
      end if

      afterScaleHeight = acuteNextY'(srcTriangle.height * scaleYToMakeAcute)
      afterScaleTheta = atn(newPrevPointX / afterScaleHeight)

      m.drawRotatedObjectTo(acuteTriRotBmp, 0, 0, -afterScaleTheta, acuteTriRegion)

      m.addDebugCell(acuteTriRotBmp, "acuteTriRotBmp")



      newLongestPoint = BGE.Math.VectorOps.create(cos(afterScaleTheta), sin(afterScaleTheta))
      yAxisPoint = newNextLength'sqr(acuteAngleOffsetToMakeItARightTriangle * acuteAngleOffsetToMakeItARightTriangle + afterScaleHeight * afterScaleHeight)


      acuteTrianglePoints = [BGE.Math.VectorOps.create(), BGE.Math.VectorOps.create(), BGE.Math.VectorOps.create()]
      yaxisPointIndex = srcTriangle.nextIndex(srcTriangle.getOriginIndex())
      acuteTrianglePoints[yaxisPointIndex] = BGE.Math.VectorOps.create(0, yAxisPoint)

      acuteTrianglePoints[srcTriangle.longestIndex] = BGE.Math.VectorOps.scale(newLongestPoint, newSrcLongest)

      '  m.addDebugCell(acuteTriRotBmp, "acuteTriRotBmp")

      acuteTriangle = new TriangleBitmap(acuteTriRotBmp, acuteTrianglePoints)
      m.bmpPool.returnRegions([scratchRegion1, scratchRegion2])

      return acuteTriangle
    end function


    private function rotateAcuteTriangleForDesiredOrigin(srcTriangle as TriangleBitmap, indexForOrigin as integer) as TriangleBitmap
      if srcTriangle.points[indexForOrigin].x = 0 and srcTriangle.points[indexForOrigin].y = 0
        return srcTriangle
      end if
      bitmapSize = srcTriangle.getLongestSide()


      rotForCorrectOrigin = CreateObject("roBitmap", {width: bitmapSize, height: bitmapSize, AlphaEnable: true})

      beforeOrigin = srcTriangle.points[indexForOrigin]
      theta = BGE.Math.HalfPi() - srcTriangle.anglesToNext[indexForOrigin]

      translation = BGE.Math.VectorOps.negative(beforeOrigin)

      m.drawRotatedImageWithCenterTo(rotForCorrectOrigin, srcTriangle.bitmap, beforeOrigin, -theta, translation)

      newTrianglePoints = [
        BGE.Math.VectorOps.create(),
        BGE.Math.VectorOps.create(),
        BGE.Math.VectorOps.create()
      ]
      nextIndex = srcTriangle.nextIndex(indexForOrigin)
      newOriginAngle = srcTriangle.angles[indexForOrigin]
      newTrianglePoints[nextIndex].y = srcTriangle.lengths[indexForOrigin]

      prevIndex = srcTriangle.nextIndex(nextIndex)

      newTrianglePoints[prevIndex].x = srcTriangle.lengths[prevIndex] * sin(srcTriangle.angles[indexForOrigin])
      newTrianglePoints[prevIndex].y = srcTriangle.lengths[prevIndex] * cos(srcTriangle.angles[indexForOrigin])

      m.drawTrianglePointsTo(rotForCorrectOrigin, newTrianglePoints)

      ' m.addDebugCell(rotForCorrectOrigin, "rotForCorrectOrigin")

      rotatedTriangle = new TriangleBitmap(rotForCorrectOrigin, newTrianglePoints)

      return rotatedTriangle
    end function

    function drawPinnedCornersTo(draw2d as ifDraw2d, cornerPoints as BGE.Math.CornerPoints, drawableRegion as RegionWithId, isMirror = false as boolean, color = -1 as integer) as boolean
      diagonalLengths = cornerPoints.computeDiagonalLengths()
      sideLengths = cornerPoints.computeSideLengths()
      srcWidth = drawableRegion.region.getWidth()
      srcHeight = drawableRegion.region.getHeight()

      splitIntoFour = false

      if splitIntoFour
        worked = true

        srcPoints = new Bge.Math.CornerPoints()

        srcPoints.topLeft = BGE.Math.VectorOps.create(0, 0)
        srcPoints.topRight = BGE.Math.VectorOps.create(srcWidth, 0)
        srcPoints.bottomLeft = BGE.Math.VectorOps.create(0, srcHeight)
        srcPoints.bottomRight = BGE.Math.VectorOps.create(srcWidth, srcHeight)

        srcCenter = srcPoints.getCenter()

        destCenter = cornerPoints.getCenter()

        src = [
          srcPoints.topLeft,
          srcCenter,
          srcPoints.topRight
        ]

        dest = [
          cornerPoints.topLeft,
          destCenter
          cornerPoints.topRight,
        ]

        worked = worked and m.drawBitmapTriangleTo(draw2d, drawableRegion, src, dest)


        src = [
          srcPoints.topRight,
          srcCenter,
          srcPoints.bottomRight
        ]

        dest = [
          cornerPoints.topRight,
          destCenter
          cornerPoints.bottomRight,
        ]

        worked = worked and m.drawBitmapTriangleTo(draw2d, drawableRegion, src, dest)

        src = [
          srcPoints.bottomRight,
          srcCenter,
          srcPoints.bottomLeft
        ]

        dest = [
          cornerPoints.bottomRight,
          destCenter
          cornerPoints.bottomLeft,
        ]

        worked = worked and m.drawBitmapTriangleTo(draw2d, drawableRegion, src, dest)
        src = [
          srcPoints.bottomLeft,
          srcCenter,
          srcPoints.topLeft
        ]

        dest = [
          cornerPoints.bottomLeft,
          destCenter
          cornerPoints.topLeft,
        ]

        worked = worked and m.drawBitmapTriangleTo(draw2d, drawableRegion, src, dest)

        return worked
      end if

      ' split into two triangles
      if true or diagonalLengths[0] > diagonalLengths[1]
        'topLeft to BottomRight Diag

        topRightSrc = [
          BGE.Math.VectorOps.create(0, 0),
          BGE.Math.VectorOps.create(srcWidth, srcHeight),
          BGE.Math.VectorOps.create(srcWidth, 0)
        ]
        bottomLeftSrc = [
          BGE.Math.VectorOps.create(srcWidth, srcHeight)
          BGE.Math.VectorOps.create(0, 0),
          BGE.Math.VectorOps.create(0, srcHeight),
        ]

        topRightDest = [
          cornerPoints.topLeft,
          cornerPoints.bottomRight,
          cornerPoints.topRight,
        ]

        bottomLeftDest = [
          cornerPoints.bottomRight,
          cornerPoints.topLeft,
          cornerPoints.bottomLeft
        ]
        worked = m.drawBitmapTriangleTo(draw2d, drawableRegion, topRightSrc, topRightDest)
        worked = worked and m.drawBitmapTriangleTo(draw2d, drawableRegion, bottomLeftSrc, bottomLeftDest)
      else
        'topRight to BottomLeft Diag

        topLeftSrc = [
          BGE.Math.VectorOps.create(0, srcHeight),
          BGE.Math.VectorOps.create(srcWidth, 0),
          BGE.Math.VectorOps.create(0, 0),

        ]
        bottomRightSrc = [
          BGE.Math.VectorOps.create(srcWidth, 0),
          BGE.Math.VectorOps.create(0, srcHeight)
          BGE.Math.VectorOps.create(srcWidth, srcHeight),
        ]

        topLeftDest = [
          cornerPoints.bottomLeft
          cornerPoints.topRight,
          cornerPoints.topLeft,
        ]

        bottomRightDest = [
          cornerPoints.topRight,
          cornerPoints.bottomLeft
          cornerPoints.bottomRight,
        ]
        worked = m.drawBitmapTriangleTo(draw2d, drawableRegion, topLeftSrc, topLeftDest)
        worked = worked and m.drawBitmapTriangleTo(draw2d, drawableRegion, bottomRightSrc, bottomRightDest)
      end if
      return worked
    end function



    function drawCircleOutline(line_count as integer, x as float, y as float, radius as float, rgba as integer) as boolean
      if not m.shouldDraw(x - radius, y - radius, radius * 2, radius * 2)
        return false
      end if

      previous_x = radius
      previous_y = 0
      for i = 0 to line_count
        degrees = 360 * (i / line_count)
        current_x = cos(degrees * .01745329) * radius
        current_y = sin(degrees * .01745329) * radius

        m.draw2d.DrawLine(x + previous_x, y + previous_y, x + current_x, y + current_y, rgba)
        m.drawCallsLastFrame++

        previous_x = current_x
        previous_y = current_y
      end for
      return true
    end function


    function drawRectangleOutline(x as float, y as float, width as float, height as float, rgba as integer) as boolean
      if not m.shouldDraw(x, y, width, height)
        return false
      end if

      m.draw2d.DrawLine(x, y, x + width, y, rgba)
      m.draw2d.DrawLine(x, y, x, y + height, rgba)
      m.draw2d.DrawLine(x + width, y, x + width, y + height, rgba)
      m.draw2d.DrawLine(x, y + height, x + width, y + height, rgba)
      m.drawCallsLastFrame += 4
      return true
    end function


    function drawPolygonOutline(pointsArray as object, colorRgba as integer) as boolean
      return m.drawPolygonOutlineTo(m.draw2d, pointsArray, colorRgba)
    end function

    function drawPolygonOutlineTo(draw2d as ifDraw2d, pointsArray as object, colorRgba as integer) as boolean
    end function


    function drawObject(x as integer, y as integer, src as object, rgba = -1 as integer) as boolean
      return m.drawObjectTo(m.draw2d, x, y, src, rgba)
    end function


    function drawObjectTo(draw2d as ifDraw2d, x as integer, y as integer, src as object, rgba = -1 as integer) as boolean
      if not m.shouldDrawTo(draw2d, x, y, src.getWidth(), src.getHeight())
        return false
      end if
      ' using undocumented ifDraw2d function
      result = (draw2d as dynamic).drawObject(fix(x), fix(y), src, rgba)
      m.drawCallsLastFrame++
      return result
    end function


    function drawScaledObject(x as integer, y as integer, scaleX as float, scaleY as float, src as object, rgba = -1 as integer) as boolean
      return m.drawScaledObjectTo(m.draw2d, x, y, scaleX, scaleY, src)
    end function

    function drawScaledObjectTo(draw2d as ifDraw2d, x as integer, y as integer, scaleX as float, scaleY as float, src as object, rgba = -1 as integer) as boolean
      if src = invalid or not m.shouldDrawTo(draw2d, x, y, src.getWidth() * scaleX, src.getHeight() * scaleY)
        return false
      end if
      result = draw2d.DrawScaledObject(fix(x), fix(y), scaleX, scaleY, src, rgba)
      m.drawCallsLastFrame++
      return result
    end function

    function drawRotatedObject(x as integer, y as integer, theta as float, src as object, rgba = -1 as integer) as boolean
      return m.drawRotatedObjectTo(m.draw2d, x, y, theta, src, rgba)
    end function

    function drawRotatedObjectTo(draw2d as ifDraw2d, x as integer, y as integer, theta as float, src as ifDraw2d, rgba = -1 as integer) as boolean
      if draw2d = invalid or src = invalid or not m.shouldDrawTo(draw2d, x, y, src.getWidth(), src.getHeight(), theta)
        return false
      end if
      thetaDeg = BGe.Math.RadiansToDegrees(theta)
      ' using undocumented ifDraw2d function
      result = (draw2d as dynamic).DrawRotatedObject(fix(x), fix(y), thetaDeg, src, rgba)
      m.drawCallsLastFrame++
      return result
    end function


    function drawRegion(regionToDraw as roRegion, x as float, y as float, scaleX = 1 as float, scaleY = 1 as float, rotation = 0 as float, RGBA = -1 as integer) as boolean
      return m.drawRegionTo(m.draw2d, regionTodraw, x, y, scaleX, scaleY, rotation, RGBA)
    end function

    function drawRegionTo(canvasDrawTo as ifDraw2d, regionToDraw as roRegion, x as float, y as float, scaleX = 1 as float, scaleY = 1 as float, rotation = 0 as float, RGBA = -1 as integer) as boolean
      if scaleX = 1 and scaleY = 1 and rotation = 0
        return m.DrawObjectTo(canvasDrawTo, x, y, regionToDraw, rgba)
      else if rotation = 0
        return m.DrawScaledObjectTo(canvasDrawTo, x, y, scaleX, scaleY, regionToDraw)
      else if scaleX = 1 and scaleY = 1
        return m.DrawRotatedObjectTo(canvasDrawTo, x, y, -rotation, regionToDraw)
      else
        return m.DrawTransformedObjectTo(canvasDrawTo, x, y, scaleX, scaleY, -rotation, regionToDraw, rgba)
      end if
      return false
    end function

    function drawTriangle(points as BGE.Math.Vector[], x as float, y as float, rgba as integer, allowQuickDraw = false) as boolean
      return m.drawTriangleTo(m.draw2d, points, x, y, rgba)
    end function

    function drawTriangleTo(canvasDrawTo as ifDraw2d, points as BGE.Math.Vector[], x as float, y as float, rgba as integer, allowQuickDraw = false) as boolean
      if points.count() <> 3
        return false
      end if

      bounds = BGE.Math.getBounds(points)
      minP = bounds[0]
      maxP = bounds[1]
      totalXOffset = x + minP.x
      totalYOffset = y + minP.y

      triangleSize = BGE.Math.VectorOps.subtract(bounds[1], bounds[0])
      if allowQuickDraw
        drawThreshold = 4
        if triangleSize.x < drawThreshold and triangleSize.y < drawThreshold
          return true
        end if
        thresholdSizeForQuickDraw = 12
        if triangleSize.x < thresholdSizeForQuickDraw and triangleSize.y < thresholdSizeForQuickDraw
          pointSize = BGE.Math.Min(triangleSize.x, triangleSize.y)
          pointOffset = 0
          return m.drawSquareTo(canvasDrawTo, totalXOffset + pointOffset, totalYOffset + pointOffset, pointSize, rgba)
        else if (triangleSize.x < thresholdSizeForQuickDraw or triangleSize.y < thresholdSizeForQuickDraw)
          return m.drawRectangleTo(canvasDrawTo, totalXOffset, totalYOffset, triangleSize.x, triangleSize.y, rgba)
        end if
      end if

      newCenter = BGE.Math.VectorOps.copy(points[0])
      newCenter.x += x
      newCenter.y += y

      srcSize = BGE.Math.VectorOps.subtract(maxP, minP)

      offsetPoints = []
      for i = 0 to 2
        point = points[i]
        offsetPoints.push(BGE.Math.VectorOps.subtract(point, minP))
      end for

      srcTriangle = new BGE.Math.Triangle(points)

      polyId = "polyTriangle"

      ' polyBitmap = m.triangleCache.getTriangle(polyId, offsetPoints)
      'if invalid = polyBitmap

      myScratchRegion = m.bmpPool.getRegion(srcSize.x, srcSize.y)
      if invalid = myScratchRegion or invalid = myScratchRegion.region
        return false
      end if

      triSrcRegion = myScratchRegion.region

      m.drawRectangleTo(triSrcRegion, 0, 0, srcSize.x, srcSize.y, rgba)
      polyBitmap = m.makeIntoTriangle(new RegionWithId(triSrcRegion, polyId), offsetPoints, false, false)
      if invalid = polyBitmap
        m.bmpPool.returnRegions([myScratchRegion])
        return false
      end if

      longestPoint = offsetPoints[srcTriangle.nextIndex(srcTriangle.longestIndex)]
      'm.drawTrianglePointsTo(polyBitmap.bitmap, offsetPoints)
      ' theta = - +
      theta = polyBitmap.angleRotatedFromOriginal

      didDraw = m.drawRotatedObjectTo(canvasDrawTo, totalXOffset + longestpoint.x, totalYoffset + longestPoint.y, theta, polyBitmap.bitmap, rgba)
      m.bmpPool.returnRegions([myScratchRegion, polyBitmap.scratchRegion])
      return didDraw
    end function



    function drawPolygon(points as BGE.Math.Vector[], x as float, y as float, rgba as integer) as boolean
      return m.drawPolygonTo(m.draw2d, points, x, y, rgba)
    end function

    function drawPolygonTo(canvasDrawTo as object, points as BGE.Math.Vector[], x as float, y as float, rgba as integer) as boolean
      if points.count() < 3
        return false
      end if
      if points.count() = 3
        return m.drawTriangleTo(canvasDrawTo, points, x, y, rgba)
      end if

      triangles = BGE.QuickHull.getTrianglesFromPoints(points, true)
      didDraw = true
      for each tri in triangles
        didDraw = m.drawTriangleTo(canvasDrawTo, tri, x, y, rgba) or didDraw
      end for

      return didDraw
    end function

    function getCanvasSize() as BGE.Math.Vector
      return BGE.Math.VectorOps.create(m.draw2d.getWidth(), m.draw2d.getHeight())
    end function

    function getCanvasCenter() as BGE.Math.Vector
      return BGE.Math.VectorOps.create(fix(m.draw2d.getWidth() / 2), fix(m.draw2d.getHeight() / 2))
    end function

    private function shouldDraw(x as float, y as float, width as float, height as float, rotation = 0 as float) as boolean
      return m.shouldDrawTo(m.draw2d, x, y, width, height, rotation)
    end function

    private function shouldDrawTo(draw2d as object, x as float, y as float, width as float, height as float, rotation = 0 as float) as boolean
      if draw2d = invalid or width = 0 or height = 0
        return false
      end if
      if not m.onlyDrawWhenInFrame
        return true
      end if
      return m.isInsideCanvas(draw2d, x, y, width, height, rotation)
    end function


    ' Checks to see if a rectangle will be in a Draw2d Canvas
    '
    ' @param {object} draw2d
    ' @param {float} x
    ' @param {float} y
    ' @param {float} width
    ' @param {float} height
    ' @return {boolean} true if this rectangle overlaps with the canvas
    function isInsideCanvas(draw2d as object, x as float, y as float, width as float, height as float, rotation = 0 as float) as boolean
      canvasWidth = draw2d.getWidth()
      canvasHeight = draw2d.getHeight()
      origx = x
      origy = y
      if rotation <> 0
        ' use diagonal as radius for seeing where rotated points could be
        ' this gives a bigger approximation for rotated objects, but is easier
        radius = Sqr(width * width + height * height)
        x = BGE.Math.Min(x, x + sin(rotation) * radius)
        y = BGE.Math.Min(y, y - sin(rotation) * radius)
        width = radius
        height = radius


      end if
      corners = [
        {x: x, y: y},
        {x: x + width, y: y},
        {x: x, y: y + height},
        {x: x + width, y: y + height}
      ]
      ' check each corner
      insideCanvas = false
      for each point in corners
        if point.x >= 0 and point.x <= canvasWidth and point.y >= 0 and point.y <= canvasHeight
          ' if one corner is in then this will be drawn
          insideCanvas = true
          exit for
        end if
      end for
      ' no corner is in the canvas, but this whole thing could overlap somehow
      if not insideCanvas and x < 0 and (x + width) > canvasWidth
        if y < 0
          insideCanvas = (y + height) >= 0
        else if y <= canvasHeight
          insideCanvas = true
        end if
      end if
      if not insideCanvas and y < 0 and (y + height) > canvasHeight
        if x < 0
          insideCanvas = (x + width) >= 0
        else if x <= canvasWidth
          insideCanvas = true
        end if
      end if

      return insideCanvas
    end function

    function drawTrianglePoints(points as BGE.Math.Vector[], size = 5 as integer, offset = {x: 0, y: 0} as PositionXY) as boolean
      return m.drawTrianglePointsTo(m.draw2d, points, size)
    end function

    function drawTrianglePointsTo(draw2dRegion as object, points as BGE.Math.Vector[], size = 5 as integer, offset = {x: 0, y: 0} as PositionXY) as boolean
      if not m.drawDebugCells
        return false
      end if
      if draw2dRegion = invalid or points = invalid or points.count() < 3
        return false
      end if
      m.drawSquareTo(draw2dRegion, points[0].x + offset.x, points[0].y + offset.y, size, BGE.Colors().Red)
      m.drawSquareTo(draw2dRegion, points[1].x + offset.x, points[1].y + offset.y, size, BGE.Colors().Green)
      m.drawSquareTo(draw2dRegion, points[2].x + offset.x, points[2].y + offset.y, size, BGE.Colors().Blue)

      return true
    end function

    function drawTriangleOutline(pointsArray as BGE.Math.Vector[], colorRgba as integer, offset = {x: 0, y: 0} as PositionXY) as boolean
      return m.drawTriangleOutlineTo(m.draw2d, pointsArray, colorRgba, offset)
    end function

    function drawTriangleOutlineTo(draw2d as ifDraw2d, pointsArray as BGE.Math.Vector[], colorRgba as integer, offset = {x: 0, y: 0} as PositionXY) as boolean
      worked = true
      for i = 0 to 2
        pThis = pointsArray[i]
        nextI = (i + 1) mod 3
        pNext = pointsArray[nextI]
        worked = m.drawLineTo(draw2d, pThis.x + offset.x, pThis.y + offset.y, pNext.x + offset.x, pNext.y + offset.y, colorRgba) and worked
      end for
      return worked
    end function


    sub addDebugCell(region as object, text = "" as string)
      if not m.drawDebugCells
        return
      end if
      regionWidth = region.getWidth()
      regionHeight = region.getHeight()
      scale = m.debugCellSize - 2
      offsetX = 1
      offsetY = 1
      if regionWidth > regionHeight
        scale = scale / regionWidth
        offsetY = m.debugCellSize / 2 - scale * regionHeight / 2 + 1
      else
        scale = scale / regionHeight
        offsetX = m.debugCellSize / 2 - scale * regionWidth / 2 + 1
      end if
      cellX = m.debugCellStart.x + m.debugCellSize * m.activeDebugCells
      cellY = m.debugCellStart.y
      textY = cellY + m.debugCellSize + 2
      m.drawRectangleOutline(cellX, cellY, m.debugCellSize, m.debugCellSize, BGE.Colors().White)

      m.draw2d.drawScaledObject(cellX + offsetX, cellY + offsetY, scale, scale, region)
      m.drawCallsLastFrame++

      debugText = `(${fix(regionWidth)}, ${fix(regionHeight)})`
      m.drawText(text, cellX, textY, BGE.Colors().White, m.game.getFont("debugUiSmall"))
      m.drawText(debugText, cellX, textY + 12, BGE.Colors().White, m.game.getFont("debugUiSmall"))
      m.activeDebugCells++
    end sub

  end class

end namespace
