namespace BGE

  ' Wrapper for Draw2D calls, so that we can keep track of how much is being drawn per frame
  class Renderer

    nextSceneObjectId = 0
    ' Frame rate target - the game will reduce quality if this target is not met
    protected minimumFrameRateTarget as integer = 12

    protected onlyDrawWhenInFrame as boolean = false

    private drawCallsLastFrame = 0
    private activeDebugCells = 0
    private debugCellSize = 100
    private debugCellStart as BGE.Math.Vector = new BGE.Math.Vector(100, 100)
    private drawDebugCells = false

    private draw2d as object = invalid

    private sceneObjects as SceneObject[] = []

    camera as Camera

    cameraPosition as BGE.Math.Vector
    worldToCamera as BGE.Math.Matrix44
    cameraRotation as BGE.Math.Vector


    triangleCache as TriangleCache = new TriangleCache()

    private game as Game

    sub new(game as BGE.Game, draw2d as object)
      m.game = game
      m.draw2d = draw2d
      m.camera = new Camera()
    end sub

    sub resetDrawCallCounter()
      m.drawCallsLastFrame = 0
      m.activeDebugCells = 0
    end sub


    sub addSceneObject(sceneObj as SceneObject)
      sceneObj.setId(m.nextSceneObjectId.toStr().trim())
      m.nextSceneObjectId++
      m.sceneObjects.push(sceneObj)
    end sub

    sub removeSceneObject(sceneObj as SceneObject)
      indexToDelete = -1
      for i = 0 to m.sceneObjects.count()
        if m.sceneObjects[i].id = sceneObj.id
          indexToDelete = i
          exit for
        end if
      end for
      if indexToDelete >= 0
        m.sceneObjects.delete(indexToDelete)
      end if
      sceneObj.id = ""
    end sub

    private sub updateSceneObjects()
      for each sceneObj in m.sceneObjects
        sceneObj.update(m.camera)
      end for

    end sub

    sub drawScene()
      m.camera.checkMovement()

      if m.camera.movedLastFrame()
        m.cameraPosition = m.camera.position' m.camera ? m.camera.position : new BGE.Math.Vector()
        lookTarget = m.camera.position.add(m.camera.orientation) ' m.camera? m.camera.orientation : new BGE.Math.Vector(0, 0, -1)
        m.worldToCamera = BGE.Math.lookAt(m.cameraPosition, lookTarget).inverse()
      end if
      m.updateSceneObjects()

      m.sceneObjects.sortBy("negDistanceFromCamera")

      ' draw sceneObjects in sorted order
      ' ignore any that are too far away (TBD) or behind camera
      for each sceneObj in m.sceneObjects
        if sceneObj.isEnabled()
          if sceneObj.negDistanceFromCamera < 0 'and sceneObj.normnegDistanceFromCamera < 10000
            sceneObj.draw(m)
          end if
        end if
      end for

    end sub


    function worldPointToCanvasPoint(pWorld as BGE.Math.Vector) as BGE.Math.Vector
      pCamera = m.worldToCamera.multVecMatrix(pWorld)
      if pCamera.z >= 0
        return invalid
      end if
      pScreen = {x: 0, y: 0}
      pScreen.x = 500 * pCamera.x / -pCamera.z
      pScreen.y = 500 * pCamera.y / -pCamera.z
      pNDC = {x: 0, y: 0}

      canvasWidth = m.draw2d.getWidth()
      canvasHeight = m.draw2d.getHeight()
      pNDC.x = (pScreen.x + canvasWidth * 0.5) / canvasWidth
      pNDC.y = (pScreen.y + canvasHeight * 0.5) / canvasHeight
      pRaster = new BGE.Math.Vector()
      imageWidth = canvasWidth
      imageHeight = canvasHeight

      pRaster.x = fix(pNDC.x * imageWidth)
      pRaster.y = cint ((1 - pNDC.y) * imageHeight)
      '? "pCamera: "; pCamera.toStr();" -> screen: [";pScreen.x;pScreen.y;"] -> NDC [";pNDC.x;pNDC.y;"] -> Raster [";pRaster.x;pRaster.y;"]"

      return pRaster
    end function



    function drawLine(x as float, y as float, endX as float, endY as float, rgba as integer) as boolean
      width = abs(x - endx)
      height = abs(y - endY)
      if not m.shouldDraw(x, y, width, height)
        return false
      end if
      m.draw2d.DrawLine(x, y, endX, endY, rgba)

      m.drawCallsLastFrame++
      return true
    end function


    function drawSquare(x as float, y as float, sideLength as float, rgba as integer) as boolean
      return m.drawSquareTo(m.draw2d, x, y, sideLength, rgba)
    end function

    function drawSquareTo(draw2D as object, x as float, y as float, sideLength as float, rgba as integer) as boolean
      if not m.shouldDrawTo(draw2D, x - sideLength / 2, y - sideLength / 2, sideLength, sideLength)
        return false
      end if
      draw2d.DrawPoint(x, y, sideLength, rgba)

      m.drawCallsLastFrame++
      return true
    end function

    ' Draws text to the screen
    '
    ' @param {string} text the test to display
    ' @param {integer} x
    ' @param {integer} y
    ' @param {object} font Font object to use
    ' @param {integer} [color=-1] RGBA color to use
    ' @param {string} [horizAlign="left"] Horizontal Alignment - "left", "right" or "center"
    ' @param {string} [vertAlign="left"] Vertical Alignment - "top", "bottom" or "center"
    function drawText(text as string, x as integer, y as integer, font as object, color = -1 as integer, horizAlign = "left" as string, vertAlign = "top" as string) as boolean
      width = font.GetOneLineWidth(text, 10000)
      height = font.GetOneLineHeight() * BGE.getNumberOfLinesInAString(text)
      textX = x
      textY = y

      if horizAlign = "right"
        textX = x - width
      else if horizAlign = "center"
        textX = x - width / 2
      end if

      if vertAlign = "bottom"
        textY = y - height
      else if vertAlign = "center"
        textY = y - height / 2
      end if
      if m.shouldDraw(textX, textY, width, height)
        m.draw2d.DrawText(text, textX, textY, color, font)
        m.drawCallsLastFrame++
        return true
      end if
      return false
    end function

    ' NOTE: This function is unsafe! It creates an roBitmap of the required size to be able to both scale and rotate the drawing, this action requires free video memory of the appropriate amount.
    function drawScaledAndRotatedObject(x as float, y as float, scaleX as float, scaleY as float, theta as float, drawable as object, rgba = -1 as integer, rotateAroundX = 0, rotateAroundY = 0) as boolean
      return m.drawScaledAndRotatedObjectTo(m.draw2d, x, y, scaleX, scaleY, theta, drawable, rgba)
    end function

    function drawScaledAndRotatedObjectTo(draw2D as object, x as float, y as float, scale_x as float, scale_y as float, theta as float, drawable as object, color = -1 as integer, rotateAroundX = 0, rotateAroundY = 0) as boolean
      new_width = Abs(int(drawable.GetWidth() * scale_x))
      new_height = Abs(int(drawable.GetHeight() * scale_y))
      xToDraw = x
      yToDraw = y

      if scale_x < 0 and scale_y > 0
        xToDraw = x + new_width
        ' scale_x = abs(scale_x)
      else if scale_y < 0 and scale_x > 0
        ' yToDraw = y + new_height
        '  scale_y = abs(scale_y)
      else if scale_y < 0 and scale_x < 0
        '  yToDraw = y + new_height
        ' xToDraw = x + new_width
        '  scale_y = abs(scale_y)
      end if

      if new_width <> 0 and new_height <> 0 and m.shouldDrawTo(draw2d, xToDraw, yToDraw, new_width, new_height, theta)
        scaledBitmap = CreateObject("roBitmap", {width: new_width, height: new_height, AlphaEnable: true})
        scaledRegion = CreateObject("roRegion", scaledBitmap, 0, 0, new_width, new_height)
        if invalid = scaledRegion
          return false
        end if
        pretranslation_x = drawable.GetPretranslationX()
        pretranslation_y = drawable.GetPretranslationY()
        newPreX = pretranslation_x * scale_x
        scaleXdrawAdjustment = 0 ' need to change draw position if scale is negative
        scaleYdrawAdjustment = 0
        if scale_x < 0
          newPreX = -newPreX
          scaleXdrawAdjustment = new_width
        end if
        newPreY = pretranslation_y * scale_y
        if scale_y < 0
          newPreY = -newPreY
          scaleYDrawAdjustment = new_height
        end if
        scaledRegion.setPretranslation(-Abs(newPreX) + rotateAroundY, -Abs(newPreY) + rotateAroundY)
        scaled_draw_x = Abs(newPreX) + scaleXdrawAdjustment
        scaled_draw_y = Abs(newPreY) + scaleYdrawAdjustment
        scaledRegion.DrawScaledObject(fix(scaled_draw_x), fix(scaled_draw_y), scale_x, scale_y, drawable)
        m.drawCallsLastFrame++

        thetaDeg = BGE.Math.RadiansToDegrees(theta)

        draw2d.DrawRotatedObject(fix(xToDraw), fix(yToDraw), thetaDeg, scaledRegion, color)
        m.drawCallsLastFrame++
        return true
      end if
      return false
    end function

    function drawPinnedCorners(cornerPoints as BGE.Math.CornerPoints, drawableRegion as RegionWithId, isMirror = false as boolean, color = -1 as integer) as boolean
      return m.drawPinnedCornersTo(m.draw2d, cornerPoints, drawableRegion, isMirror, color)
    end function


    function drawRotatedImageWithCenterTo(draw2D as object, srcRegion as object, center as BGE.Math.Vector, theta as float, translation = new BGE.Math.Vector() as BGE.Math.Vector) as boolean
      distanceToCenter = center.length()
      angleToCenter = BGE.Math.GetAngle(new BGE.Math.Vector(), center)
      centerRotationAngle = theta - angleToCenter
      rotatedCenter = new BGE.Math.Vector(distanceToCenter * cos(centerRotationAngle), -distanceToCenter * sin(centerRotationAngle))
      finalTranslation = translation.add(center.subtract(rotatedCenter))
      return m.drawRotatedObjectTo(draw2D, finalTranslation.x, finalTranslation.y, theta, srcRegion)
    end function


    function makeIntoTriangle(srcRegionWithId as RegionWithId, points as BGE.Math.Vector[]) as TriangleBitmap

      existingItem = m.triangleCache.getTriangle(srcRegionWithId.id, points)
      if invalid <> existingItem
        return existingItem
      end if


      srcRegion = srcRegionWithId.region

      if points.count() < 3
        return invalid
      end if
      canGetPoints = true
      for i = 0 to 2
        canGetPoints = canGetPoints and m.isInsideCanvas(srcRegion, points[i].x, points[i].y, 1, 1, 0)
        if not canGetPoints
          exit for
        end if
      end for
      if not canGetPoints
        return invalid
      end if
      srcTri = new BGE.Math.Triangle(points, false)

      m.addDebugCell(srcRegion, "srcRegion")

      halfPi = BGE.Math.halfPI()
      longestIndex = srcTri.longestIndex
      startIndex = srcTri.nextIndex(longestIndex)
      longestSide = srcTri.getLongestSide()
      bitmap = CreateObject("roBitmap", {width: longestSide, height: longestSide, AlphaEnable: true})
      originPoint = srcTri.points[startIndex]

      initialRegion = CreateObject("roRegion", bitmap, 0, 0, longestSide, longestSide)
      if invalid = initialRegion
        return invalid
      end if
      initialRegion.SetScaleMode(1)
      initialAngle = srcTri.anglesToPrevious[startIndex]
      initialCenter = originPoint.negative()
      m.drawRotatedImageWithCenterTo(initialRegion, srcRegion, originPoint, initialAngle, initialCenter)

      m.addDebugCell(initialRegion, "initialRegion")

      ' At this point, we have region where the top line is the longest side of the triangle
      ' find the angle to rotate to cut off the right side
      prevIndex = srcTri.previousIndex(startIndex)
      rightSideTheta = -initialAngle - halfPi + srcTri.anglesToPrevious[prevIndex]' - halfPi - srcTri.anglesToPrevious[prevIndex]
      bitmap2 = CreateObject("roBitmap", {width: longestSide, height: longestSide, AlphaEnable: true})
      region2 = CreateObject("roRegion", bitmap2, 0, 0, longestSide, longestSide)
      if invalid = region2
        return invalid
      end if
      region2.SetScaleMode(1)
      m.drawRotatedImageWithCenterTo(region2, initialRegion, new BGE.Math.Vector(longestSide, 0), rightSideTheta)


      m.addDebugCell(region2, "region2")

      bitmap3 = CreateObject("roBitmap", {width: longestSide, height: longestSide, AlphaEnable: true})
      region3 = CreateObject("roRegion", bitmap3, 0, 0, longestSide, longestSide)
      if invalid = region3
        return invalid
      end if

      region3.SetScaleMode(1)
      prevIndex = srcTri.previousIndex(prevIndex)

      lastRotCenter = new BGE.Math.Vector(longestSide - longestSide * cos(rightSideTheta), longestSide * sin(rightSideTheta))
      leftSideTheta = -srcTri.angles[prevIndex]
      m.drawRotatedImageWithCenterTo(region3, region2, lastRotCenter, leftSideTheta, lastRotCenter.negative())





      resultPoints = [new BGE.Math.Vector(), new BGE.Math.Vector(), new BGE.Math.Vector()]


      ' nextSrcIndex = srcTri.nextIndex(longestIndex)
      ' resultPoints[1].y = srcTri.lengths[nextSrcIndex]

      ' resultPoints[2]



      ' next point is always mapped to (0,0)
      index = (longestIndex + 1) mod 3
      resultPoints[index].x = 0
      resultPoints[index].y = 0

      ' prevPoint is always on the y-axis
      nextLength = srcTri.lengths[index]
      index = (index + 1) mod 3
      resultPoints[index].y = nextLength ' prevpoint is where the next leg ends

      ' last point(longestPoint) is found via trig
      index = longestIndex

      finalAngle = srcTri.angles[(longestIndex + 1) mod 3]
      resultPoints[index].x = longestSide * cos(halfPi - finalAngle)
      resultPoints[index].y = longestSide * sin(halfPi - finalAngle)


      m.drawTrianglePointsTo(region3, resultPoints)

      result = new TriangleBitmap(region3, resultPoints)

      m.addDebugCell(region3, "triangle")

      if not result.isAcute()
        ' Make the cached triangles Acute, so it is easier to transform them into obtuse triangles later
        result = m.scaleTriangleToBeAcuteTriangle(result)
        m.addDebugCell(result.bitmap, "acutetriangle")
      end if

      m.triangleCache.addTriangle(srcRegionWithId.id, points, result)
      return result
    end function

    function drawBitmapTriangleTo(draw2D as object, srcRegionWithId as RegionWithId, srcPoints as BGE.Math.Vector[], destPoints as BGE.Math.Vector[]) as boolean
      if srcPoints.count() < 3 or destPoints.count() < 3
        return false
      end if
      shouldDraw = false
      for i = 0 to 3
        shouldDraw = shouldDraw or m.shouldDrawTo(draw2d, destPoints[i].x, destPoints[i].y, 1, 1, 0)
        if shouldDraw
          exit for
        end if
      end for
      if not shouldDraw
        return false
      end if

      srcTriangle = m.makeIntoTriangle(srcRegionWithId, srcPoints)
      srcRegion = srcRegionWithId.region
      if invalid = srcTriangle
        return false
      end if

      destTriangle = new BGE.Math.Triangle(destPoints)
      srcOriginIndex = srcTriangle.getOriginIndex()

      if srcOriginIndex <> destTriangle.nextIndex(destTriangle.longestIndex) and destTriangle.isObtuse()
        'rearrange srcTriangle so side that corresponds to dest's longest side is on top of a bitmap
        srcTriangle = m.rotateAcuteTriangleForDesiredOrigin(srcTriangle, destTriangle.nextIndex(destTriangle.longestIndex))
      end if

      pivotIndex = srcTriangle.previousIndex(srcTriangle.getOriginIndex())

      nextIndex = srcTriangle.nextIndex(pivotIndex)
      prevIndex = srcTriangle.nextIndex(nextIndex)


      finalBitmapWidth = destTriangle.getLongestSide() * 1.33
      finalBitmapHeight = finalBitmapWidth


      mappedLongestLength = destTriangle.lengths[pivotIndex]
      mappedPreviousLength = destTriangle.lengths[prevIndex]
      mappedNextLength = destTriangle.lengths[nextIndex]




      srcScales = m.getScalesForTriangleMapping(srcTriangle, destTriangle)
      srcXScale = srcScales.x
      srcYScale = srcScales.y

      srcPivot = srcTriangle.points[pivotIndex]
      mappedOriginPointAfterLengthSet = new BGE.Math.Vector(srcPivot.x * srcXScale, srcPivot.y * srcYScale)
      changedPointOnYAxis = srcTriangle.points[prevIndex].copy()
      changedPointOnYAxis.y *= srcYScale

      angleToMappedLongest = BGE.Math.GetAngle(new BGE.Math.Vector(), mappedOriginPointAfterLengthSet)
      distanceToMappedLongest = mappedOriginPointAfterLengthSet.length()
      scaledSrcBitmap = CreateObject("roBitmap", {width: distanceToMappedLongest, height: changedPointOnYAxis.y, AlphaEnable: true})
      scaledSrcRegion = CreateObject("roRegion", scaledSrcBitmap, 0, 0, distanceToMappedLongest, changedPointOnYAxis.y)
      if invalid = scaledSrcRegion
        return false
      end if
      scaledSrcRegion.SetScaleMode(1)
      m.drawScaledObjectTo(scaledSrcRegion, 0, 0, srcXScale, srcYScale, srcTriangle.bitmap)

      m.drawTrianglePointsTo(scaledSrcRegion, [
        new BGE.Math.Vector(),
        changedPointOnYAxis,
        mappedOriginPointAfterLengthSet
      ])

      m.addDebugCell(scaledSrcRegion, "scaledSrcRegion")

      destOrigin = destTriangle.points[nextIndex]

      finalAngle = BGE.Math.GetAngle(destOrigin, destTriangle.points[pivotIndex])
      rotatedTriHeight = changedPointOnYAxis.y * cos(angleToMappedLongest)
      rotatedRegionHeight = rotatedTriHeight
      rotatedBitmap = CreateObject("roBitmap", {width: distanceToMappedLongest, height: rotatedRegionHeight, AlphaEnable: true})
      rotatedRegion = CreateObject("roRegion", rotatedBitmap, 0, 0, distanceToMappedLongest, rotatedRegionHeight)
      if rotatedRegion = invalid
        return false
      end if
      rotatedRegion.SetScaleMode(1)

      angleToMappedLongest = Bge.Math.Max(angleToMappedLongest, 0.05)

      m.drawRotatedObjectTo(rotatedRegion, 0, 0, angleToMappedLongest, scaledSrcRegion)

      m.addDebugCell(rotatedRegion, "rotatedRegion")
      firstPartLength = BGE.Math.Max(changedPointOnYAxis.y * sin(angleToMappedLongest), 0)

      secondPartLength = distanceToMappedLongest - firstPartLength

      firstPartRegion = CreateObject("roRegion", rotatedBitmap, 0, 0, firstPartLength, rotatedTriHeight)

      if invalid = firstPartRegion
        return false
      end if
      firstPartRegion.SetScaleMode(1)

      secondPartRegion = CreateObject("roRegion", rotatedBitmap, BGE.Math.Max(0, firstPartLength - 1), 0, secondPartLength, rotatedTriHeight)
      if invalid = secondPartRegion
        return false
      end if
      secondPartRegion.SetScaleMode(1)
      destFirstPartWidth = mappedNextLength * cos(destTriangle.angles[nextIndex])
      destSecondPartWidth = mappedLongestLength - destFirstPartWidth

      firstPartScaleX = 0
      if firstPartLength > 0
        firstPartScaleX = destFirstPartWidth / firstPartLength
      end if

      secondPartScaleX = 0
      if secondPartLength > 0
        secondPartScaleX = destSecondPartWidth / secondPartLength
      end if
      if rotatedTriHeight = 0
        return false
      end if

      finalScaleY = destTriangle.getHeightByTangentIndex(nextIndex) / rotatedTriHeight

      finalBitmap = CreateObject("roBitmap", {width: finalBitmapWidth, height: finalBitmapHeight, AlphaEnable: true})
      finalRegion = CreateObject("roRegion", finalBitmap, 0, 0, finalBitmapWidth, finalBitmapHeight)

      if invalid = finalRegion
        return false
      end if

      m.addDebugCell(firstPartRegion, "firstPartRegion")

      m.addDebugCell(secondPartRegion, "secondPartRegion")


      finalRegion.SetScaleMode(1)
      didDraw = true
      if firstPartScaleX <> 0
        didDraw = m.DrawScaledObjectTo(finalRegion, 0, 0, firstPartScaleX * 1.01, finalScaleY * 1.01, firstPartRegion)
      end if
      if didDraw and invalid <> secondPartRegion
        didDraw = m.DrawScaledObjectTo(finalRegion, destFirstPartWidth - 1, 0, secondPartScaleX * 1.01, finalScaleY * 1.01, secondPartRegion)
      end if

      m.addDebugCell(finalRegion, "finalRegion")
      if(didDraw)
        didDraw = m.drawRotatedObjectTo(draw2d, destOrigin.x, destOrigin.y, -finalAngle, finalRegion)
      end if
      return didDraw
    end function

    private function getScalesForTriangleMapping(srcTriangle as BGE.Math.Triangle, destTriangle as BGE.Math.Triangle) as BGE.Math.Vector

      srcXScale = 1
      srcYScale = 1
      foundXScale = false



      pivotIndex = srcTriangle.previousIndex(srcTriangle.getOriginIndex())

      nextIndex = srcTriangle.nextIndex(pivotIndex)
      prevIndex = srcTriangle.nextIndex(nextIndex)
      mappedLongestLength = destTriangle.lengths[pivotIndex]
      mappedPreviousLength = destTriangle.lengths[prevIndex]
      mappedNextLength = destTriangle.lengths[nextIndex]

      srcLongestLength = srcTriangle.lengths[pivotIndex]
      srcPreviousLength = srcTriangle.lengths[prevIndex]
      srcNextLength = srcTriangle.lengths[nextIndex]

      srcOriginPointX = srcTriangle.points[pivotIndex].x

      destFirstPartWidth = mappedNextLength * cos(destTriangle.angles[nextIndex])
      destSecondPartWidth = mappedLongestLength - destFirstPartWidth
      if destSecondPartWidth > 0 and destFirstPartWidth > 0
        k = destFirstPartWidth / destSecondPartWidth
        y = srcNextLength
        y1 = srcTriangle.points[pivotIndex].y
        y2 = y - y1

        insideSqr = ((y * y + y1 * y1 - y2 * y2) / (2 * k * k + 2 * k))

        if insideSqr > 0
          beta = sqr(insideSqr)
          alpha = beta * k
          c = alpha + beta
          insideSqr2 = c * c - y1 * y1
          if insideSqr2 > 0
            whereSrcOriginPointXNeedsToBe = sqr(insideSqr2)

            whereSrcOriginPointXNeedsToBe = BGE.Math.min(whereSrcOriginPointXNeedsToBe, 10 * mappedLongestLength)
            ?" Scale found 0"
            foundXScale = true
          end if
        end if
      end if

      if not foundXScale
        srcYScale = mappedNextLength / srcTriangle.lengths[nextIndex]
        srcPointOnYAxis = srcTriangle.points[prevIndex]
        changedPointOnYAxis = srcPointOnYAxis.copy()
        changedPointOnYAxis.y *= srcYScale
        changedPointOnYAxisYDelta = mappedNextLength - srcTriangle.lengths[nextIndex]
        srcOriginPointYAfterScale = srcTriangle.points[pivotIndex].y * srcYScale
      end if
      if not foundXScale
        ' Scale so yAxis edge and bottom edge are correct length for dest
        pythagorasLeg = mappedNextLength - srcOriginPointYAfterScale
        insideSqrForLegs = mappedPreviousLength * mappedPreviousLength - pythagorasLeg * pythagorasLeg
        if insideSqrForLegs > 0
          whereSrcOriginPointXNeedsToBe = sqr(insideSqrForLegs)
          checkLength = whereSrcOriginPointXNeedsToBe * whereSrcOriginPointXNeedsToBe - srcOriginPointYAfterScale * srcOriginPointYAfterScale
          if checklength > 0
            ?" Scale found 1"
            foundXScale = true
          end if
        end if
      end if

      if not foundXScale
        'make angle at origin the same as the "nextAngle" of destTri
        whereSrcOriginPointXNeedsToBe = srcOriginPointYAfterScale * tan(destTriangle.angles[nextIndex])
        checkLength = whereSrcOriginPointXNeedsToBe * whereSrcOriginPointXNeedsToBe - srcOriginPointYAfterScale * srcOriginPointYAfterScale
        if checklength > 0
          ?" Scale found 2"
          foundXScale = true
        end if
      end if

      if not foundXScale
        ' Scale so yAxis edge and top edge are correct length for dest
        insideSqrForTopSide = mappedLongestLength * mappedLongestLength - srcOriginPointYAfterScale * srcOriginPointYAfterScale
        if insideSqrForTopSide > 0
          whereSrcOriginPointXNeedsToBe = sqr(insideSqrForTopSide)
          ?" Scale found 3"
          foundXScale = true
        end if
      end if

      if not foundXScale
        ' Scale so point's x is equal to dest longest length
        whereSrcOriginPointXNeedsToBe = mappedLongestLength
        ?" Scale found 4"
        foundXScale = true
      end if


      if srcOriginPointX <> 0
        srcXScale = whereSrcOriginPointXNeedsToBe / srcOriginPointX
      end if
      return new BGE.Math.vector(srcXScale, srcYScale)
    end function


    ' There can be problems transforming a source triangle to a destination triangle when they are obtuse and the longest sides don't match up
    ' This function will scale a source triangle along the axis of its longest side so that it is an acute-triangle
    private function scaleTriangleToBeAcuteTriangle(srcTriangle as TriangleBitmap) as TriangleBitmap
      pivotIndex = srcTriangle.previousIndex(srcTriangle.getOriginIndex())
      nextIndex = srcTriangle.nextIndex(pivotIndex)
      prevIndex = srcTriangle.nextIndex(nextIndex)

      pointA = srcTriangle.points[pivotIndex]
      pointB = srcTriangle.points[nextIndex]
      pointC = srcTriangle.points[prevIndex]

      srcLongestLength = srcTriangle.getLongestSide()
      srcNextLength = srcTriangle.lengths[nextIndex]
      srcPrevLength = srcTriangle.lengths[prevIndex]

      firstRotation = srcTriangle.anglesToPrevious[nextIndex]

      rotatedSrcBitmap = CreateObject("roBitmap", {width: srcLongestLength, height: srcLongestLength, AlphaEnable: true})
      'rotatedSrcRegion = CreateObject("roRegion", rotatedSrcBitmap, 0, 0, finalBitmapWidth, finalBitmapHeight)

      m.drawRotatedObjectTo(rotatedSrcBitmap, 0, 0, firstRotation, srcTriangle.bitmap)

      newPrevPointX = srcNextLength * cos(firstRotation)

      m.addDebugCell(rotatedSrcBitmap, "rotatedSrcBitmap")


      ' Scaling from Y-axis will mean the ration between triangle legs will be constant
      ' So we can set that ratio equal to tan(newNextAngle) and use atn() to get newNextAngle
      ' Once We know newNextAngle, we can use its complement to find the distance of the acuteAngle of the scaled triangle
      ' from the y-axis
      ' And from that, get the scale

      ratio = srcNextLength / srcPrevLength
      newNextAngle = atn(ratio)

      acuteAngleOffset = srcTriangle.height * tan(BGE.Math.halfPI() - newNextAngle)

      scaleX = acuteAngleOffset / newPrevPointX

      newSrcLongest = srcLongestLength * scaleX
      newNextLength = srcNextLength * scaleX

      acuteTriBitmap = CreateObject("roBitmap", {width: srcLongestLength, height: srcLongestLength, AlphaEnable: true})
      '  acuteTriangleSrcRegion = CreateObject("roRegion", rotatedSrcBitmap, 0, 0, finalBitmapWidth, finalBitmapHeight)

      scaleYToMakeAcute = 1.5
      m.drawScaledObjectTo(acuteTriBitmap, 0, 0, scaleX, scaleYToMakeAcute, rotatedSrcBitmap)

      '   m.addDebugCell(acuteTriBitmap, "acuteTriBitmap")


      acuteTriRotBmp = CreateObject("roBitmap", {width: srcLongestLength, height: srcLongestLength, AlphaEnable: true})
      '  acuteTriangleSrcRegion = CreateObject("roRegion", rotatedSrcBitmap, 0, 0, finalBitmapWidth, finalBitmapHeight)

      afterScaleHeight = (srcTriangle.height * scaleYToMakeAcute)
      afterScaleTheta = atn(acuteAngleOffset / afterScaleHeight)

      m.drawRotatedObjectTo(acuteTriRotBmp, 0, 0, -afterScaleTheta, acuteTriBitmap)


      newLongestPoint = new BGE.Math.Vector(cos(afterScaleTheta), sin(afterScaleTheta))
      yAxisPoint = sqr(acuteAngleOffset * acuteAngleOffset + afterScaleHeight * afterScaleHeight)


      acuteTrianglePoints = [new BGE.Math.Vector(), new BGE.Math.Vector(), new BGE.Math.Vector()]
      yaxisPointIndex = srcTriangle.nextIndex(srcTriangle.getOriginIndex())
      acuteTrianglePoints[yaxisPointIndex] = new BGE.Math.Vector(0, yAxisPoint)

      acuteTrianglePoints[srcTriangle.longestIndex] = newLongestPoint.scale(newSrcLongest)

      '  m.addDebugCell(acuteTriRotBmp, "acuteTriRotBmp")

      acuteTriangle = new TriangleBitmap(acuteTriRotBmp, acuteTrianglePoints)

      return acuteTriangle
    end function


    private function rotateAcuteTriangleForDesiredOrigin(srcTriangle as TriangleBitmap, indexForOrigin as integer) as TriangleBitmap
      if srcTriangle.points[indexForOrigin].x = 0 and srcTriangle.points[indexForOrigin].y = 0
        return srcTriangle
      end if
      bitmapSize = srcTriangle.getLongestSide()

      rotForCorrectOrigin = CreateObject("roBitmap", {width: bitmapSize, height: bitmapSize, AlphaEnable: true})

      beforeOrigin = srcTriangle.points[indexForOrigin]
      theta = BGE.Math.HalfPi() - srcTriangle.anglesToNext[indexForOrigin]

      translation = beforeOrigin.negative()

      m.drawRotatedImageWithCenterTo(rotForCorrectOrigin, srcTriangle.bitmap, beforeOrigin, -theta, translation)

      newTrianglePoints = [
        new BGE.Math.Vector(),
        new BGE.Math.Vector(),
        new BGE.Math.Vector()
      ]
      nextIndex = srcTriangle.nextIndex(indexForOrigin)
      newOriginAngle = srcTriangle.angles[indexForOrigin]
      newTrianglePoints[nextIndex].y = srcTriangle.lengths[indexForOrigin]

      prevIndex = srcTriangle.nextIndex(nextIndex)

      newTrianglePoints[prevIndex].x = srcTriangle.lengths[prevIndex] * sin(srcTriangle.angles[indexForOrigin])
      newTrianglePoints[prevIndex].y = srcTriangle.lengths[prevIndex] * cos(srcTriangle.angles[indexForOrigin])

      m.drawTrianglePointsTo(rotForCorrectOrigin, newTrianglePoints)

      ' m.addDebugCell(rotForCorrectOrigin, "rotForCorrectOrigin")

      rotatedTriangle = new TriangleBitmap(rotForCorrectOrigin, newTrianglePoints)

      return rotatedTriangle
    end function

    function drawPinnedCornersTo(draw2D as object, cornerPoints as BGE.Math.CornerPoints, drawableRegion as RegionWithId, isMirror = false as boolean, color = -1 as integer) as boolean
      diagonalLengths = cornerPoints.computeDiagonalLengths()
      sideLengths = cornerPoints.computeSideLengths()
      srcWidth = drawableRegion.region.getWidth()
      srcHeight = drawableRegion.region.getHeight()

      splitIntoFour = false

      if splitIntoFour
        srcPoints = new Bge.Math.CornerPoints()

        srcPoints.topLeft = new BGE.Math.Vector(0, 0)
        srcPoints.topRight = new BGE.Math.Vector(srcWidth, 0)
        srcPoints.bottomLeft = new BGE.Math.Vector(0, srcHeight)
        srcPoints.bottomRight = new BGE.Math.Vector(srcWidth, srcHeight)

        srcCenter = srcPoints.getCenter()

        destCenter = cornerPoints.getCenter()

        src = [
          srcPoints.topLeft,
          srcCenter,
          srcPoints.topRight
        ]

        dest = [
          cornerPoints.topLeft,
          destCenter
          cornerPoints.topRight,
        ]

        worked = m.drawBitmapTriangleTo(draw2d, drawableRegion, src, dest)


        src = [
          srcPoints.topRight,
          srcCenter,
          srcPoints.bottomRight
        ]

        dest = [
          cornerPoints.topRight,
          destCenter
          cornerPoints.bottomRight,
        ]

        worked = worked and m.drawBitmapTriangleTo(draw2d, drawableRegion, src, dest)

        src = [
          srcPoints.bottomRight,
          srcCenter,
          srcPoints.bottomLeft
        ]

        dest = [
          cornerPoints.bottomRight,
          destCenter
          cornerPoints.bottomLeft,
        ]

        worked = worked and m.drawBitmapTriangleTo(draw2d, drawableRegion, src, dest)
        src = [
          srcPoints.bottomLeft,
          srcCenter,
          srcPoints.topLeft
        ]

        dest = [
          cornerPoints.bottomLeft,
          destCenter
          cornerPoints.topLeft,
        ]

        worked = worked and m.drawBitmapTriangleTo(draw2d, drawableRegion, src, dest)

        return worked
      end if

      ' split into two triangles
      if true or diagonalLengths[0] > diagonalLengths[1]
        'topLeft to BottomRight Diag

        topRightSrc = [
          new BGE.Math.Vector(0, 0),
          new BGE.Math.Vector(srcWidth, srcHeight),
          new BGE.Math.Vector(srcWidth, 0)
        ]
        bottomLeftSrc = [
          new BGE.Math.Vector(srcWidth, srcHeight)
          new BGE.Math.Vector(0, 0),
          new BGE.Math.Vector(0, srcHeight),
        ]

        topRightDest = [
          cornerPoints.topLeft,
          cornerPoints.bottomRight,
          cornerPoints.topRight,
        ]

        bottomLeftDest = [
          cornerPoints.bottomRight,
          cornerPoints.topLeft,
          cornerPoints.bottomLeft
        ]
        worked = m.drawBitmapTriangleTo(draw2d, drawableRegion, topRightSrc, topRightDest)
        worked = worked and m.drawBitmapTriangleTo(draw2d, drawableRegion, bottomLeftSrc, bottomLeftDest)
      else
        'topRight to BottomLeft Diag

        topLeftSrc = [
          new BGE.Math.Vector(0, srcHeight),
          new BGE.Math.Vector(srcWidth, 0),
          new BGE.Math.Vector(0, 0),

        ]
        bottomRightSrc = [
          new BGE.Math.Vector(srcWidth, 0),
          new BGE.Math.Vector(0, srcHeight)
          new BGE.Math.Vector(srcWidth, srcHeight),
        ]

        topLeftDest = [
          cornerPoints.bottomLeft
          cornerPoints.topRight,
          cornerPoints.topLeft,
        ]

        bottomRightDest = [
          cornerPoints.topRight,
          cornerPoints.bottomLeft
          cornerPoints.bottomRight,
        ]
        worked = m.drawBitmapTriangleTo(draw2d, drawableRegion, topLeftSrc, topLeftDest)
        worked = worked and m.drawBitmapTriangleTo(draw2d, drawableRegion, bottomRightSrc, bottomRightDest)
      end if
      return worked
    end function



    function drawCircleOutline(line_count as integer, x as float, y as float, radius as float, rgba as integer) as boolean
      if not m.shouldDraw(x - radius, y - radius, radius * 2, radius * 2)
        return false
      end if

      previous_x = radius
      previous_y = 0
      for i = 0 to line_count
        degrees = 360 * (i / line_count)
        current_x = cos(degrees * .01745329) * radius
        current_y = sin(degrees * .01745329) * radius

        m.draw2d.DrawLine(x + previous_x, y + previous_y, x + current_x, y + current_y, rgba)
        m.drawCallsLastFrame++

        previous_x = current_x
        previous_y = current_y
      end for
      return true
    end function


    function drawRectangleOutline(x as float, y as float, width as float, height as float, rgba as integer) as boolean
      if not m.shouldDraw(x, y, width, height)
        return false
      end if

      m.draw2d.DrawLine(x, y, x + width, y, rgba)
      m.draw2d.DrawLine(x, y, x, y + height, rgba)
      m.draw2d.DrawLine(x + width, y, x + width, y + height, rgba)
      m.draw2d.DrawLine(x, y + height, x + width, y + height, rgba)
      m.drawCallsLastFrame += 4
      return true
    end function



    function drawPolygon(pointsArray as object, colorRgba as integer) as boolean
      return m.drawPolygonTo(m.draw2d, pointsArray, colorRgba)
    end function

    function drawPolygonTo(draw2d as object, pointsArray as object, colorRgba as integer) as boolean
    end function

    function drawPolygonOutline(pointsArray as object, colorRgba as integer) as boolean
      return m.drawPolygonOutlineTo(m.draw2d, pointsArray, colorRgba)
    end function

    function drawPolygonOutlineTo(draw2d as object, pointsArray as object, colorRgba as integer) as boolean
    end function


    function drawObject(x as integer, y as integer, src as object) as boolean
      return m.drawObjectTo(m.draw2d, x, y, src)
    end function


    function drawObjectTo(draw2d as object, x as integer, y as integer, src as object) as boolean
      if not m.shouldDrawTo(draw2d, x, y, src.getWidth(), src.getHeight())
        return false
      end if
      draw2d.drawObject(fix(x), fix(y), src)
      m.drawCallsLastFrame++
      return true
    end function


    function drawScaledObject(x as integer, y as integer, scaleX as float, scaleY as float, src as object) as boolean
      return m.drawScaledObjectTo(m.draw2d, x, y, scaleX, scaleY, src)
    end function

    function drawScaledObjectTo(draw2d as object, x as integer, y as integer, scaleX as float, scaleY as float, src as object) as boolean
      if not m.shouldDrawTo(draw2d, x, y, src.getWidth() * scaleX, src.getHeight() * scaleY)
        return false
      end if
      draw2d.DrawScaledObject(fix(x), fix(y), scaleX, scaleY, src)
      m.drawCallsLastFrame++
      return true
    end function

    function drawRotatedObject(x as integer, y as integer, theta as float, src as object) as boolean
      return m.drawRotatedObjectTo(m.draw2d, x, y, theta, src)
    end function

    function drawRotatedObjectTo(draw2d as object, x as integer, y as integer, theta as float, src as object) as boolean
      if not m.shouldDrawTo(draw2d, x, y, src.getWidth(), src.getHeight(), theta)
        return false
      end if
      thetaDeg = BGe.Math.RadiansToDegrees(theta)
      draw2d.DrawRotatedObject(fix(x), fix(y), thetaDeg, src)
      m.drawCallsLastFrame++
      return true
    end function


    function drawRegion(regionToDraw as object, x as float, y as float, scaleX = 1 as float, scaleY = 1 as float, rotation = 0 as float, RGBA = -1 as integer) as boolean
      return m.drawRegionTo(m.draw2d, regionTodraw, x, y, scaleX, scaleY, rotation, RGBA)
    end function

    function drawRegionTo(canvasDrawTo as object, regionToDraw as object, x as float, y as float, scaleX = 1 as float, scaleY = 1 as float, rotation = 0 as float, RGBA = -1 as integer) as boolean
      if scaleX = 1 and scaleY = 1 and rotation = 0
        return m.DrawObjectTo(canvasDrawTo, x, y, regionToDraw)
      else if rotation = 0
        return m.DrawScaledObjectTo(canvasDrawTo, x, y, scaleX, scaleY, regionToDraw)
      else if scaleX = 1 and scaleY = 1
        return m.DrawRotatedObjectTo(canvasDrawTo, x, y, -rotation, regionToDraw)
      else
        return m.DrawScaledAndRotatedObjectTo(canvasDrawTo, x, y, scaleX, scaleY, -rotation, regionToDraw, rgba)
      end if
      return false
    end function


    private function shouldDraw(x as float, y as float, width as float, height as float, rotation = 0 as float) as boolean
      return m.shouldDrawTo(m.draw2d, x, y, width, height, rotation)
    end function

    private function shouldDrawTo(draw2d as object, x as float, y as float, width as float, height as float, rotation = 0 as float) as boolean
      if not m.onlyDrawWhenInFrame
        return true
      end if
      if width = 0 or height = 0
        return false
      end if
      return m.isInsideCanvas(draw2d, x, y, width, height, rotation)
    end function


    ' Checks to see if a rectangle will be in a Draw2d Canvas
    '
    ' @param {object} draw2d
    ' @param {float} x
    ' @param {float} y
    ' @param {float} width
    ' @param {float} height
    ' @return {boolean} true if this rectangle overlaps with the canvas
    function isInsideCanvas(draw2d as object, x as float, y as float, width as float, height as float, rotation = 0 as float) as boolean
      canvasWidth = draw2d.getWidth()
      canvasHeight = draw2d.getHeight()
      if rotation <> 0
        ' use diagonal as radius for seeing were rotated points could be
        ' this gives a bigger approximation for rotated objects, but is easier
        radius = Sqr(width * width + height * height)
        x = BGE.Math.Min(x, x + cos(rotation) * radius)
        y = BGE.Math.Min(y, y + sin(rotation) * radius)
        width = radius
        height = radius
      end if
      ' check each corner
      corners = [
        {x: x, y: y},
        {x: x + width, y: y},
        {x: x, y: y + height},
        {x: x + width, y: y + height}
      ]
      insideCanvas = false
      for each point in corners
        if x >= 0 and x <= canvasWidth and y >= 0 and y <= canvasHeight
          ' if one corner is in then this will be drawn
          insideCanvas = true
          exit for
        end if
      end for
      ' no corner is in the canvas, but this whole thing could overlap somehow
      if not insideCanvas and x < 0 and (x + width) > canvasWidth
        if y < 0
          insideCanvas = (y + height) >= 0
        else if y <= canvasHeight
          insideCanvas = true
        end if
      end if
      if not insideCanvas and y < 0 and (y + height) > canvasHeight
        if x < 0
          insideCanvas = (x + width) >= 0
        else if x <= canvasWidth
          insideCanvas = true
        end if
      end if

      return insideCanvas
    end function


    function drawTrianglePointsTo(draw2dRegion as object, points as BGE.Math.Vector[], size = 5 as integer) as boolean
      if not m.drawDebugCells
        return false
      end if
      if draw2dRegion = invalid or points = invalid or points.count() < 3
        return false
      end if
      m.drawSquareTo(draw2dRegion, points[0].x, points[0].y, size, BGE.Colors().Red)
      m.drawSquareTo(draw2dRegion, points[1].x, points[1].y, size, BGE.Colors().Green)
      m.drawSquareTo(draw2dRegion, points[2].x, points[2].y, size, BGE.Colors().Blue)

      return true
    end function




    sub addDebugCell(region as object, text = "" as string)
      if not m.drawDebugCells
        return
      end if
      regionWidth = region.getWidth()
      regionHeight = region.getHeight()
      scale = m.debugCellSize - 2
      offsetX = 1
      offsetY = 1
      if regionWidth > regionHeight
        scale = scale / regionWidth
        offsetY = m.debugCellSize / 2 - scale * regionHeight / 2 + 1
      else
        scale = scale / regionHeight
        offsetX = m.debugCellSize / 2 - scale * regionWidth / 2 + 1
      end if
      cellX = m.debugCellStart.x + m.debugCellSize * m.activeDebugCells
      cellY = m.debugCellStart.y
      textY = cellY + m.debugCellSize + 2
      m.drawRectangleOutline(cellX, cellY, m.debugCellSize, m.debugCellSize, BGE.Colors().White)

      m.draw2d.drawScaledObject(cellX + offsetX, cellY + offsetY, scale, scale, region)
      ' m.drawRegionToCanvas(region, m.draw2d, cellX + offsetX, cellY + offsetY, scale, scale)
      debugText = `(${fix(regionWidth)}, ${fix(regionHeight)})`
      m.drawText(text, cellX, textY, m.game.getFont("debugUiSmall"))
      m.drawText(debugText, cellX, textY + 12, m.game.getFont("debugUiSmall"))
      m.drawCallsLastFrame += 3
      m.activeDebugCells++
    end sub

  end class

end namespace
