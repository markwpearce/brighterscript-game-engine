namespace BGE

  ' Wrapper for Draw2D calls, so that we can keep track of how much is being drawn per frame
  class Renderer

    nextSceneObjectId = 0
    ' Frame rate target - the game will reduce quality if this target is not met
    protected minimumFrameRateTarget as integer = 12

    protected onlyDrawWhenInFrame as boolean = false

    private drawCallsLastFrame = 0
    private activeDebugCells = 0
    private debugCellSize = 100
    private debugCellStart as BGE.Math.Vector = new BGE.Math.Vector(100, 100)
    private drawDebugCells = false

    private draw2d as object = invalid

    private sceneObjects as SceneObject[] = []

    camera as Camera

    cameraPosition as BGE.Math.Vector
    worldToCamera as BGE.Math.Matrix44
    cameraRotation as BGE.Math.Vector


    triangleCache as TriangleCache = new TriangleCache()

    private game as Game

    sub new(game as BGE.Game, draw2d as object)
      m.game = game
      m.draw2d = draw2d
      m.camera = new Camera()
    end sub

    sub resetDrawCallCounter()
      m.drawCallsLastFrame = 0
      m.activeDebugCells = 0
    end sub


    sub addSceneObject(sceneObj as SceneObject)
      sceneObj.setId(m.nextSceneObjectId.toStr().trim())
      m.nextSceneObjectId++
      m.sceneObjects.push(sceneObj)
    end sub

    sub removeSceneObject(sceneObj as SceneObject)
      indexToDelete = -1
      for i = 0 to m.sceneObjects.count()
        if m.sceneObjects[i].id = sceneObj.id
          indexToDelete = i
          exit for
        end if
      end for
      if indexToDelete >= 0
        m.sceneObjects.delete(indexToDelete)
      end if
      sceneObj.id = ""
    end sub

    private sub updateSceneObjects()
      for each sceneObj in m.sceneObjects
        sceneObj.update(m.camera)
      end for

    end sub

    sub drawScene()
      m.camera.checkMovement()

      if m.camera.movedLastFrame()
        m.cameraPosition = m.camera.position' m.camera ? m.camera.position : new BGE.Math.Vector()
        lookTarget = m.camera.position.add(m.camera.orientation) ' m.camera? m.camera.orientation : new BGE.Math.Vector(0, 0, -1)
        m.worldToCamera = BGE.Math.lookAt(m.cameraPosition, lookTarget).inverse()
      end if
      m.updateSceneObjects()

      m.sceneObjects.sortBy("negDistanceFromCamera")

      ' draw sceneObjects in sorted order
      ' ignore any that are too far away (TBD) or behind camera
      for each sceneObj in m.sceneObjects
        if sceneObj.isEnabled()
          if sceneObj.negDistanceFromCamera < 0 'and sceneObj.normnegDistanceFromCamera < 10000
            sceneObj.draw(m)
          end if
        end if
      end for

    end sub


    function worldPointToCanvasPoint(pWorld as BGE.Math.Vector) as BGE.Math.Vector
      pCamera = m.worldToCamera.multVecMatrix(pWorld)
      if pCamera.z >= 0
        return invalid
      end if
      pScreen = {x: 0, y: 0}
      pScreen.x = 500 * pCamera.x / -pCamera.z
      pScreen.y = 500 * pCamera.y / -pCamera.z
      pNDC = {x: 0, y: 0}

      canvasWidth = m.draw2d.getWidth()
      canvasHeight = m.draw2d.getHeight()
      pNDC.x = (pScreen.x + canvasWidth * 0.5) / canvasWidth
      pNDC.y = (pScreen.y + canvasHeight * 0.5) / canvasHeight
      pRaster = new BGE.Math.Vector()
      imageWidth = canvasWidth
      imageHeight = canvasHeight

      pRaster.x = (pNDC.x * imageWidth)
      pRaster.y = ((1 - pNDC.y) * imageHeight)
      '? "pCamera: "; pCamera.toStr();" -> screen: [";pScreen.x;pScreen.y;"] -> NDC [";pNDC.x;pNDC.y;"] -> Raster [";pRaster.x;pRaster.y;"]"

      return pRaster
    end function



    function drawLine(x as float, y as float, endX as float, endY as float, rgba as integer) as boolean
      width = abs(x - endx)
      height = abs(y - endY)
      if not m.shouldDraw(x, y, width, height)
        return false
      end if
      m.draw2d.DrawLine(x, y, endX, endY, rgba)

      m.drawCallsLastFrame++
      return true
    end function


    function drawSquare(x as float, y as float, sideLength as float, rgba as integer) as boolean
      return m.drawSquareTo(m.draw2d, x, y, sideLength, rgba)
    end function

    function drawSquareTo(draw2D as object, x as float, y as float, sideLength as float, rgba as integer) as boolean
      if not m.shouldDrawTo(draw2D, x - sideLength / 2, y - sideLength / 2, sideLength, sideLength)
        return false
      end if
      draw2d.DrawPoint(x, y, sideLength, rgba)

      m.drawCallsLastFrame++
      return true
    end function

    ' Draws text to the screen
    '
    ' @param {string} text the test to display
    ' @param {integer} x
    ' @param {integer} y
    ' @param {object} font Font object to use
    ' @param {integer} [color=-1] RGBA color to use
    ' @param {string} [horizAlign="left"] Horizontal Alignment - "left", "right" or "center"
    ' @param {string} [vertAlign="left"] Vertical Alignment - "top", "bottom" or "center"
    function drawText(text as string, x as integer, y as integer, font as object, color = -1 as integer, horizAlign = "left" as string, vertAlign = "top" as string) as boolean
      width = font.GetOneLineWidth(text, 10000)
      height = font.GetOneLineHeight() * BGE.getNumberOfLinesInAString(text)
      textX = x
      textY = y

      if horizAlign = "right"
        textX = x - width
      else if horizAlign = "center"
        textX = x - width / 2
      end if

      if vertAlign = "bottom"
        textY = y - height
      else if vertAlign = "center"
        textY = y - height / 2
      end if
      if m.shouldDraw(textX, textY, width, height)
        m.draw2d.DrawText(text, textX, textY, color, font)
        m.drawCallsLastFrame++
        return true
      end if
      return false
    end function

    ' NOTE: This function is unsafe! It creates an roBitmap of the required size to be able to both scale and rotate the drawing, this action requires free video memory of the appropriate amount.
    function drawScaledAndRotatedObject(x as float, y as float, scaleX as float, scaleY as float, theta as float, drawable as object, rgba = -1 as integer, rotateAroundX = 0, rotateAroundY = 0) as boolean
      return m.drawScaledAndRotatedObjectTo(m.draw2d, x, y, scaleX, scaleY, theta, drawable, rgba)
    end function

    function drawScaledAndRotatedObjectTo(draw2D as object, x as float, y as float, scale_x as float, scale_y as float, theta as float, drawable as object, color = -1 as integer, rotateAroundX = 0, rotateAroundY = 0) as boolean
      new_width = Abs(int(drawable.GetWidth() * scale_x))
      new_height = Abs(int(drawable.GetHeight() * scale_y))
      xToDraw = x
      yToDraw = y

      if scale_x < 0 and scale_y > 0
        xToDraw = x + new_width
        ' scale_x = abs(scale_x)
      else if scale_y < 0 and scale_x > 0
        ' yToDraw = y + new_height
        '  scale_y = abs(scale_y)
      else if scale_y < 0 and scale_x < 0
        '  yToDraw = y + new_height
        ' xToDraw = x + new_width
        '  scale_y = abs(scale_y)
      end if

      if new_width <> 0 and new_height <> 0 and m.shouldDrawTo(draw2d, xToDraw, yToDraw, new_width, new_height, theta)
        scaledBitmap = CreateObject("roBitmap", {width: new_width, height: new_height, AlphaEnable: true})
        scaledRegion = CreateObject("roRegion", scaledBitmap, 0, 0, new_width, new_height)
        if invalid = scaledRegion
          return false
        end if
        pretranslation_x = drawable.GetPretranslationX()
        pretranslation_y = drawable.GetPretranslationY()
        newPreX = pretranslation_x * scale_x
        scaleXdrawAdjustment = 0 ' need to change draw position if scale is negative
        scaleYdrawAdjustment = 0
        if scale_x < 0
          newPreX = -newPreX
          scaleXdrawAdjustment = new_width
        end if
        newPreY = pretranslation_y * scale_y
        if scale_y < 0
          newPreY = -newPreY
          scaleYDrawAdjustment = new_height
        end if
        scaledRegion.setPretranslation(-Abs(newPreX) + rotateAroundY, -Abs(newPreY) + rotateAroundY)
        scaled_draw_x = Abs(newPreX) + scaleXdrawAdjustment
        scaled_draw_y = Abs(newPreY) + scaleYdrawAdjustment
        scaledRegion.DrawScaledObject(scaled_draw_x, scaled_draw_y, scale_x, scale_y, drawable)
        m.drawCallsLastFrame++

        thetaDeg = BGE.Math.RadiansToDegrees(theta)

        draw2d.DrawRotatedObject(xToDraw, yToDraw, thetaDeg, scaledRegion, color)
        m.drawCallsLastFrame++
        return true
      end if
      return false
    end function

    function drawPinnedCorners(cornerPoints as BGE.Math.CornerPoints, drawableRegion as RegionWithId, isMirror = false as boolean, color = -1 as integer) as boolean
      return m.drawPinnedCornersTo(m.draw2d, cornerPoints, drawableRegion, isMirror, color)
    end function


    function drawRotatedImageWithCenterTo(draw2D as object, srcRegion as object, center as BGE.Math.Vector, theta as float, translation = new BGE.Math.Vector() as BGE.Math.Vector) as boolean
      distanceToCenter = center.length()
      angleToCenter = BGE.Math.GetAngle(new BGE.Math.Vector(), center)
      centerRotationAngle = theta - angleToCenter
      rotatedCenter = new BGE.Math.Vector(distanceToCenter * cos(centerRotationAngle), -distanceToCenter * sin(centerRotationAngle))
      finalTranslation = translation.add(center.subtract(rotatedCenter))
      return m.drawRotatedObjectTo(draw2D, finalTranslation.x, finalTranslation.y, theta, srcRegion)
    end function


    function makeIntoTriangle(srcRegionWithId as RegionWithId, points as BGE.Math.Vector[]) as TriangleBitmap

      existingItem = m.triangleCache.getTriangle(srcRegionWithId.id, points)
      if invalid <> existingItem
        return existingItem
      end if


      srcRegion = srcRegionWithId.region

      if points.count() < 3
        return invalid
      end if
      canGetPoints = true
      for i = 0 to 2
        canGetPoints = canGetPoints and m.isInsideCanvas(srcRegion, points[i].x, points[i].y, 1, 1, 0)
        if not canGetPoints
          exit for
        end if
      end for
      if not canGetPoints
        return invalid
      end if
      srcTri = new BGE.Math.Triangle(points, false)

      m.addDebugCell(srcRegion, "srcRegion")

      halfPi = BGE.Math.halfPI()
      longestIndex = srcTri.longestIndex
      startIndex = srcTri.nextIndex(longestIndex)
      longestSide = srcTri.getLongestSide()
      bitmap = CreateObject("roBitmap", {width: longestSide, height: longestSide, AlphaEnable: true})
      originPoint = srcTri.points[startIndex]

      initialRegion = CreateObject("roRegion", bitmap, 0, 0, longestSide, longestSide)
      if invalid = initialRegion
        return invalid
      end if
      initialRegion.SetScaleMode(1)
      initialAngle = srcTri.anglesToPrevious[startIndex]
      initialCenter = originPoint.negative()
      m.drawRotatedImageWithCenterTo(initialRegion, srcRegion, originPoint, initialAngle, initialCenter)

      m.addDebugCell(initialRegion, "initialRegion")

      ' At this point, we have region where the top line is the longest side of the triangle
      ' find the angle to rotate to cut off the right side
      prevIndex = srcTri.previousIndex(startIndex)
      rightSideTheta = -initialAngle - halfPi + srcTri.anglesToPrevious[prevIndex]' - halfPi - srcTri.anglesToPrevious[prevIndex]
      bitmap2 = CreateObject("roBitmap", {width: longestSide, height: longestSide, AlphaEnable: true})
      region2 = CreateObject("roRegion", bitmap2, 0, 0, longestSide, longestSide)
      if invalid = region2
        return invalid
      end if
      region2.SetScaleMode(1)
      m.drawRotatedImageWithCenterTo(region2, initialRegion, new BGE.Math.Vector(longestSide, 0), rightSideTheta)


      m.addDebugCell(region2, "region2")

      bitmap3 = CreateObject("roBitmap", {width: longestSide, height: longestSide, AlphaEnable: true})
      region3 = CreateObject("roRegion", bitmap3, 0, 0, longestSide, longestSide)
      if invalid = region3
        return invalid
      end if

      region3.SetScaleMode(1)
      prevIndex = srcTri.previousIndex(prevIndex)

      lastRotCenter = new BGE.Math.Vector(longestSide - longestSide * cos(rightSideTheta), longestSide * sin(rightSideTheta))
      'leftSideTheta = -rightSideTheta - (halfPi - srcTri.angles[longestIndex])
      leftSideTheta = -srcTri.angles[prevIndex]' MAYBE???
      m.drawRotatedImageWithCenterTo(region3, region2, lastRotCenter, leftSideTheta, lastRotCenter.negative())


      resultPoints = [new BGE.Math.Vector(), new BGE.Math.Vector(), new BGE.Math.Vector()]
      ' next point is always mapped to (0,0)
      index = (longestIndex + 1) mod 3
      resultPoints[index].x = 0
      resultPoints[index].y = 0

      ' prevPoint is always on the y-axis
      nextLength = srcTri.lengths[index]
      index = (index + 1) mod 3
      resultPoints[index].y = nextLength ' prevpoint is where the next leg ends

      ' last point(longestPoint) is found via trig
      index = longestIndex

      finalAngle = srcTri.angles[(longestIndex + 1) mod 3]
      resultPoints[index].x = longestSide * cos(halfPi - finalAngle)
      resultPoints[index].y = longestSide * sin(halfPi - finalAngle)

      m.drawSquareTo(region3, resultPoints[0].x, resultPoints[0].y, 10, BGE.Colors().Red)
      m.drawSquareTo(region3, resultPoints[1].x, resultPoints[1].y, 10, BGE.Colors().Green)
      m.drawSquareTo(region3, resultPoints[2].x, resultPoints[2].y, 10, BGE.Colors().Blue)

      result = new TriangleBitmap(region3, resultPoints)




      m.addDebugCell(region3, "triangle")

      m.triangleCache.addTriangle(srcRegionWithId.id, points, result)
      return result
    end function

    function drawBitmapTriangleTo(draw2D as object, srcRegionWithId as RegionWithId, srcPoints as BGE.Math.Vector[], destPoints as BGE.Math.Vector[]) as boolean
      if srcPoints.count() < 3 or destPoints.count() < 3
        return false
      end if
      shouldDraw = false
      for i = 0 to 3
        shouldDraw = shouldDraw or m.shouldDrawTo(draw2d, destPoints[i].x, destPoints[i].y, 1, 1, 0)
        if shouldDraw
          exit for
        end if
      end for
      if not shouldDraw
        return false
      end if

      srcTriangle = m.makeIntoTriangle(srcRegionWithId, srcPoints)
      srcRegion = srcRegionWithId.region
      if invalid = srcTriangle
        return false
      end if
      srcTriBitmap = srcTriangle.bitmap

      origTriWidth = srcTriBitmap.getWidth()
      origTriheight = srcTriBitmap.getHeight()

      origTriBitmap = CreateObject("roBitmap", {width: origTriWidth, height: origTriheight, AlphaEnable: true})
      origTriRegion = CreateObject("roRegion", origTriBitmap, 0, 0, origTriWidth, origTriheight)
      m.drawObjectTo(origTriRegion, 0, 0, srcTriangle.bitmap)
      for each point in srcTriangle.points
        m.drawSquareTo(origTriRegion, point.x, point.y, 10, BGE.Colors().Red)
      end for
      m.addDebugCell(origTriRegion, "origTriRegion")
      destTriangle = new BGE.Math.Triangle(destPoints)

      if srcTriangle.longestIndex <> destTriangle.longestIndex and srcTriangle.isObtuse() and false
        ' Cut SrcTriangle halfway on longest index, and make it into two triangles, each acute!

        ' A ->(longest) B -> C
        ' CUT AB in two (D), making two new triangles:
        ' A -> D -> C and D -> B -> C

        srcTriangle = new BGE.Math.Triangle(srcPoints)
        srcLongestIndex = srcTriangle.longestIndex

        pointA = srcPoints[srcLongestIndex]
        srcNextIndex = srcTriangle.nextIndex(srcLongestIndex)
        pointB = srcPoints[srcNextIndex]
        pointC = srcPoints[srcTriangle.nextIndex(srcNextIndex)]
        pointD = BGE.Math.midPointBetweenPoints(pointA, pointB)

        srcTriOnePoints = [pointA, pointD, pointC]
        srcTriTwoPoints = [pointD, pointB, pointC]




      end if

      'rearrange srcTriangle so side that corresponds to dest's longest side is on top of a bitmap
      originIndex = srcTriangle.longestIndex
      nextIndex = srcTriangle.nextIndex(originIndex)
      prevIndex = srcTriangle.nextIndex(nextIndex)
      finalBitmapWidth = destTriangle.getLongestSide()
      finalBitmapHeight = destTriangle.getLongestSide()

      scaledSrcBitmap = CreateObject("roBitmap", {width: finalBitmapWidth, height: finalBitmapHeight, AlphaEnable: true})
      scaledSrcRegion = CreateObject("roRegion", scaledSrcBitmap, 0, 0, finalBitmapWidth, finalBitmapHeight)
      if invalid = scaledSrcRegion
        return false
      end if
      scaledSrcRegion.SetScaleMode(1)
      mappedLongestLength = destTriangle.lengths[originIndex]
      mappedPreviousLength = destTriangle.lengths[prevIndex]
      mappedNextLength = destTriangle.lengths[nextIndex]

      srcYScale = mappedNextLength / srcTriangle.lengths[nextIndex]
      srcPointOnYAxis = srcTriangle.points[prevIndex]
      changedPointOnYAxis = srcPointOnYAxis.copy()
      changedPointOnYAxis.y *= srcYScale
      changedPointOnYAxisYDelta = mappedNextLength - srcTriangle.lengths[nextIndex]
      longestPointYAfterScale = srcTriangle.points[originIndex].y * srcYScale
      longestPointX = srcTriangle.points[originIndex].x

      if longestPointX = 0
        return false
      end if

      pythagorasLeg = mappedNextLength - longestPointYAfterScale
      'SrcXScale & srcYScale should scale so "longestPoint" is in correct place, not that prevSide & nextSide are correct length
      whereLongestPointXNeedsToBe = sqr(mappedPreviousLength * mappedPreviousLength - pythagorasLeg * pythagorasLeg)
      srcXScale = whereLongestPointXNeedsToBe / longestPointX


      'srcXScale = sqr((mappedLongestLength * mappedLongestLength - longestPointY * longestPointY) / (longestPointX * longestPointX))

      mappedLongestPointAfterLengthSet = new BGE.Math.Vector(whereLongestPointXNeedsToBe, longestPointYAfterScale)

      angleToMappedLongest = BGE.Math.GetAngle(new BGE.Math.Vector(), mappedLongestPointAfterLengthSet)
      distanceToMappedLongest = mappedLongestPointAfterLengthSet.length()

      m.drawScaledObjectTo(scaledSrcRegion, 0, 0, srcXScale, srcYScale, srcTriangle.bitmap)
      'm.drawSquareTo(scaledSrcRegion, mappedLongestPointAfterLengthSet.x, mappedLongestPointAfterLengthSet.y, 10, BGE.Colors().Red)

      m.addDebugCell(scaledSrcRegion, "scaledSrcRegion")

      destOrigin = destTriangle.points[nextIndex]

      finalAngle = BGE.Math.GetAngle(destOrigin, destTriangle.points[originIndex])

      rotatedBitmap = CreateObject("roBitmap", {width: finalBitmapWidth * 1.5, height: finalBitmapHeight * 1.5, AlphaEnable: true})
      rotatedRegion = CreateObject("roRegion", rotatedBitmap, 0, 0, finalBitmapWidth * 1.5, finalBitmapHeight * 1.5)
      rotatedRegion.SetScaleMode(1)
      m.drawRotatedObjectTo(rotatedRegion, 0, 0, angleToMappedLongest, scaledSrcRegion)

      firstPartX = mappedNextLength * sin(angleToMappedLongest)
      rotatedTriHeight = mappedNextLength * cos(angleToMappedLongest)

      'm.drawSquareTo(rotatedRegion, firstPartX, rotatedTriHeight, 10, BGE.Colors().Green)
      m.addDebugCell(rotatedRegion, "rotatedRegion")

      firstPartRegion = CreateObject("roRegion", rotatedBitmap, 0, 0, firstPartX, rotatedTriHeight)
      secondPartRegion = CreateObject("roRegion", rotatedBitmap, firstPartX, 0, distanceToMappedLongest - firstPartX, rotatedTriHeight)
      destFirstPartWidth = mappedNextLength * cos(destTriangle.angles[nextIndex])
      destSecondPartWidth = mappedLongestLength - destFirstPartWidth

      firstPartScaleX = destFirstPartWidth / firstPartX
      secondPartScaleX = destSecondPartWidth / (distanceToMappedLongest - firstPartX)
      finalScaleY = destTriangle.getHeightByTangentIndex(nextIndex) / rotatedTriHeight

      ' finalScaleX = finalBitmapWidth / mappedLongestPointAfterLengthSet.length()
      'finalScaleY = destTriangle.height / (sin(bge.Math.halfPI() - angleToMappedLongest) * mappedPreviousLength)
      finalBitmap = CreateObject("roBitmap", {width: finalBitmapWidth, height: finalBitmapHeight, AlphaEnable: true})
      finalRegion = CreateObject("roRegion", finalBitmap, 0, 0, finalBitmapWidth, finalBitmapHeight)
      finalRegion.SetScaleMode(1)

      didDraw = m.DrawScaledObjectTo(finalRegion, 0, 0, firstPartScaleX, finalScaleY, firstPartRegion)
      if didDraw and invalid <> secondPartRegion
        didDraw = m.DrawScaledObjectTo(finalRegion, destFirstPartWidth - 1, 0, secondPartScaleX, finalScaleY, secondPartRegion)
      end if

      m.addDebugCell(finalRegion, "finalRegion")
      if(didDraw)
        didDraw = m.drawRotatedObjectTo(draw2d, destOrigin.x, destOrigin.y, -finalAngle, finalRegion)
      end if
      return didDraw
    end function


    function drawPinnedCornersTo(draw2D as object, cornerPoints as BGE.Math.CornerPoints, drawableRegion as RegionWithId, isMirror = false as boolean, color = -1 as integer) as boolean
      diagonalLengths = cornerPoints.computeDiagonalLengths()
      sideLengths = cornerPoints.computeSideLengths()
      srcWidth = drawableRegion.region.getWidth()
      srcHeight = drawableRegion.region.getHeight()

      splitIntoFour = false

      if splitIntoFour
        srcPoints = new Bge.Math.CornerPOints()

        srcPoints.topLeft = new BGE.Math.Vector(0, 0)
        srcPoints.topRight = new BGE.Math.Vector(srcWidth, 0)
        srcPoints.bottomLeft = new BGE.Math.Vector(0, srcHeight)
        srcPoints.bottomRight = new BGE.Math.Vector(srcWidth, srcHeight)

        srcCenter = srcPoints.getCenter()

        destCenter = cornerPoints.getCenter()

        src = [
          srcPoints.topLeft,
          srcCenter,
          srcPoints.topRight
        ]

        dest = [
          cornerPoints.topLeft,
          destCenter
          cornerPoints.topRight,
        ]

        worked = m.drawBitmapTriangleTo(draw2d, drawableRegion, src, dest)


        src = [
          srcPoints.topRight,
          srcCenter,
          srcPoints.bottomRight
        ]

        dest = [
          cornerPoints.topRight,
          destCenter
          cornerPoints.bottomRight,
        ]

        worked = worked and m.drawBitmapTriangleTo(draw2d, drawableRegion, src, dest)

        src = [
          srcPoints.bottomRight,
          srcCenter,
          srcPoints.bottomLeft
        ]

        dest = [
          cornerPoints.bottomRight,
          destCenter
          cornerPoints.bottomLeft,
        ]

        worked = worked and m.drawBitmapTriangleTo(draw2d, drawableRegion, src, dest)
        src = [
          srcPoints.bottomLeft,
          srcCenter,
          srcPoints.topLeft
        ]

        dest = [
          cornerPoints.bottomLeft,
          destCenter
          cornerPoints.topLeft,
        ]

        worked = worked and m.drawBitmapTriangleTo(draw2d, drawableRegion, src, dest)

        return worked
      end if

      ' split into two triangles
      if diagonalLengths[0] > diagonalLengths[1]
        'topLeft to BottomRight Diag

        topRightSrc = [
          new BGE.Math.Vector(0, 0),
          new BGE.Math.Vector(srcWidth, srcHeight),
          new BGE.Math.Vector(srcWidth, 0)
        ]
        bottomLeftSrc = [
          new BGE.Math.Vector(0, 0),
          new BGE.Math.Vector(0, srcHeight),
          new BGE.Math.Vector(srcWidth, srcHeight)
        ]

        topRightDest = [
          cornerPoints.topLeft,
          cornerPoints.bottomRight,
          cornerPoints.topRight,
        ]

        bottomLeftDest = [
          cornerPoints.topLeft,
          cornerPoints.bottomLeft
          cornerPoints.bottomRight,
        ]
        worked = m.drawBitmapTriangleTo(draw2d, drawableRegion, topRightSrc, topRightDest)
        worked = worked and m.drawBitmapTriangleTo(draw2d, drawableRegion, bottomLeftSrc, bottomLeftDest)
      else
        'topRight to BottomLeft Diag

        topLeftSrc = [
          new BGE.Math.Vector(0, 0),
          new BGE.Math.Vector(0, srcHeight),
          new BGE.Math.Vector(srcWidth, 0),
        ]
        bottomRightSrc = [
          new BGE.Math.Vector(srcWidth, 0),
          new BGE.Math.Vector(0, srcHeight)
          new BGE.Math.Vector(srcWidth, srcHeight),
        ]

        topLeftDest = [
          cornerPoints.topLeft,
          cornerPoints.bottomLeft
          cornerPoints.topRight,
        ]

        bottomRightDest = [
          cornerPoints.topRight,
          cornerPoints.bottomLeft
          cornerPoints.bottomRight,
        ]
        worked = m.drawBitmapTriangleTo(draw2d, drawableRegion, topLeftSrc, topLeftDest)
        worked = worked and m.drawBitmapTriangleTo(draw2d, drawableRegion, bottomRightSrc, bottomRightDest)
      end if
      return worked
    end function



    function drawCircleOutline(line_count as integer, x as float, y as float, radius as float, rgba as integer) as boolean
      if not m.shouldDraw(x - radius, y - radius, radius * 2, radius * 2)
        return false
      end if

      previous_x = radius
      previous_y = 0
      for i = 0 to line_count
        degrees = 360 * (i / line_count)
        current_x = cos(degrees * .01745329) * radius
        current_y = sin(degrees * .01745329) * radius

        m.draw2d.DrawLine(x + previous_x, y + previous_y, x + current_x, y + current_y, rgba)
        m.drawCallsLastFrame++

        previous_x = current_x
        previous_y = current_y
      end for
      return true
    end function


    function drawRectangleOutline(x as float, y as float, width as float, height as float, rgba as integer) as boolean
      if not m.shouldDraw(x, y, width, height)
        return false
      end if

      m.draw2d.DrawLine(x, y, x + width, y, rgba)
      m.draw2d.DrawLine(x, y, x, y + height, rgba)
      m.draw2d.DrawLine(x + width, y, x + width, y + height, rgba)
      m.draw2d.DrawLine(x, y + height, x + width, y + height, rgba)
      m.drawCallsLastFrame += 4
      return true
    end function



    function drawPolygon(pointsArray as object, colorRgba as integer) as boolean
      return m.drawPolygonTo(m.draw2d, pointsArray, colorRgba)
    end function

    function drawPolygonTo(draw2d as object, pointsArray as object, colorRgba as integer) as boolean
    end function

    function drawPolygonOutline(pointsArray as object, colorRgba as integer) as boolean
      return m.drawPolygonOutlineTo(m.draw2d, pointsArray, colorRgba)
    end function

    function drawPolygonOutlineTo(draw2d as object, pointsArray as object, colorRgba as integer) as boolean
    end function


    function drawObject(x as integer, y as integer, src as object) as boolean
      return m.drawObjectTo(m.draw2d, x, y, src)
    end function


    function drawObjectTo(draw2d as object, x as integer, y as integer, src as object) as boolean
      if not m.shouldDrawTo(draw2d, x, y, src.getWidth(), src.getHeight())
        return false
      end if
      draw2d.drawObject(x, y, src)
      m.drawCallsLastFrame++
      return true
    end function


    function drawScaledObject(x as integer, y as integer, scaleX as float, scaleY as float, src as object) as boolean
      return m.drawScaledObjectTo(m.draw2d, x, y, scaleX, scaleY, src)
    end function

    function drawScaledObjectTo(draw2d as object, x as integer, y as integer, scaleX as float, scaleY as float, src as object) as boolean
      if not m.shouldDrawTo(draw2d, x, y, src.getWidth() * scaleX, src.getHeight() * scaleY)
        return false
      end if
      draw2d.DrawScaledObject(x, y, scaleX, scaleY, src)
      m.drawCallsLastFrame++
      return true
    end function

    function drawRotatedObject(x as integer, y as integer, theta as float, src as object) as boolean
      return m.drawRotatedObjectTo(m.draw2d, x, y, theta, src)
    end function

    function drawRotatedObjectTo(draw2d as object, x as integer, y as integer, theta as float, src as object) as boolean
      if not m.shouldDrawTo(draw2d, x, y, src.getWidth(), src.getHeight(), theta)
        return false
      end if
      thetaDeg = BGe.Math.RadiansToDegrees(theta)
      draw2d.DrawRotatedObject(x, y, thetaDeg, src)
      m.drawCallsLastFrame++
      return true
    end function


    function drawRegion(regionToDraw as object, x as float, y as float, scaleX = 1 as float, scaleY = 1 as float, rotation = 0 as float, RGBA = -1 as integer) as boolean
      return m.drawRegionTo(m.draw2d, regionTodraw, x, y, scaleX, scaleY, rotation, RGBA)
    end function

    function drawRegionTo(canvasDrawTo as object, regionToDraw as object, x as float, y as float, scaleX = 1 as float, scaleY = 1 as float, rotation = 0 as float, RGBA = -1 as integer) as boolean
      if scaleX = 1 and scaleY = 1 and rotation = 0
        return m.DrawObjectTo(canvasDrawTo, x, y, regionToDraw)
      else if rotation = 0
        return m.DrawScaledObjectTo(canvasDrawTo, x, y, scaleX, scaleY, regionToDraw)
      else if scaleX = 1 and scaleY = 1
        return m.DrawRotatedObjectTo(canvasDrawTo, x, y, -rotation, regionToDraw)
      else
        return m.DrawScaledAndRotatedObjectTo(canvasDrawTo, x, y, scaleX, scaleY, -rotation, regionToDraw, rgba)
      end if
      return false
    end function


    private function shouldDraw(x as float, y as float, width as float, height as float, rotation = 0 as float) as boolean
      return m.shouldDrawTo(m.draw2d, x, y, width, height, rotation)
    end function

    private function shouldDrawTo(draw2d as object, x as float, y as float, width as float, height as float, rotation = 0 as float) as boolean
      if not m.onlyDrawWhenInFrame
        return true
      end if
      return m.isInsideCanvas(draw2d, x, y, width, height, rotation)
    end function


    ' Checks to see if a rectangle will be in a Draw2d Canvas
    '
    ' @param {object} draw2d
    ' @param {float} x
    ' @param {float} y
    ' @param {float} width
    ' @param {float} height
    ' @return {boolean} true if this rectangle overlaps with the canvas
    function isInsideCanvas(draw2d as object, x as float, y as float, width as float, height as float, rotation = 0 as float) as boolean
      canvasWidth = draw2d.getWidth()
      canvasHeight = draw2d.getHeight()
      if rotation <> 0
        ' use diagonal as radius for seeing were rotated points could be
        ' this gives a bigger approximation for rotated objects, but is easier
        radius = Sqr(width * width + height * height)
        x = BGE.Math.Min(x, x + cos(rotation) * radius)
        y = BGE.Math.Min(y, y + sin(rotation) * radius)
        width = radius
        height = radius
      end if
      ' check each corner
      corners = [
        {x: x, y: y},
        {x: x + width, y: y},
        {x: x, y: y + height},
        {x: x + width, y: y + height}
      ]
      insideCanvas = false
      for each point in corners
        if x >= 0 and x <= canvasWidth and y >= 0 and y <= canvasHeight
          ' if one corner is in then this will be drawn
          insideCanvas = true
          exit for
        end if
      end for
      ' no corner is in the canvas, but this whole thing could overlap somehow
      if not insideCanvas and x < 0 and (x + width) > canvasWidth
        if y < 0
          insideCanvas = (y + height) >= 0
        else if y <= canvasHeight
          insideCanvas = true
        end if
      end if
      if not insideCanvas and y < 0 and (y + height) > canvasHeight
        if x < 0
          insideCanvas = (x + width) >= 0
        else if x <= canvasWidth
          insideCanvas = true
        end if
      end if

      return insideCanvas
    end function

    sub addDebugCell(region as object, text = "" as string)

      if not m.drawDebugCells
        return
      end if
      regionWidth = region.getWidth()
      regionHeight = region.getHeight()
      scale = m.debugCellSize - 2
      offsetX = 1
      offsetY = 1
      if regionWidth > regionHeight
        scale = scale / regionWidth
        offsetY = m.debugCellSize / 2 - scale * regionHeight / 2 + 1
      else
        scale = scale / regionHeight
        offsetX = m.debugCellSize / 2 - scale * regionWidth / 2 + 1
      end if
      cellX = m.debugCellStart.x + m.debugCellSize * m.activeDebugCells
      cellY = m.debugCellStart.y
      textY = cellY + m.debugCellSize + 2
      m.drawRectangleOutline(cellX, cellY, m.debugCellSize, m.debugCellSize, BGE.Colors().White)

      m.draw2d.drawScaledObject(cellX + offsetX, cellY + offsetY, scale, scale, region)
      ' m.drawRegionToCanvas(region, m.draw2d, cellX + offsetX, cellY + offsetY, scale, scale)
      debugText = `(${cint(regionWidth)}, ${cint(regionHeight)})`
      m.drawText(text, cellX, textY, m.game.getFont("debugUiSmall"))
      m.drawText(debugText, cellX, textY + 12, m.game.getFont("debugUiSmall"))
      m.drawCallsLastFrame += 3
      m.activeDebugCells++
    end sub

  end class

end namespace
