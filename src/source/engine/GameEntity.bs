' @module BGE
namespace BGE

  ' Every thing (character, player, object, etc) in the game should extend this class.
  ' This class has a number of empty methods that are designed to be overridden in subclasses.
  ' For example, override `onInput()` to handle input event, and `onUpdate()` to handle updating each frame
  class GameEntity
    '-----Constants-----

    ' Constant - name of this Entity
    name as string
    ' Constant - Unique Id
    id as string

    private game as Game

    ' -----Variables-----

    ' Is this GameEntity enabled
    enabled as boolean = true
    ' Does this entity persist across room changes?
    persistent as boolean = false
    ' When the game is paused, does this entity pause too?
    pauseable as boolean = true

    ' position of where this entity is in game world
    position as BGE.Math.Vector = new BGE.Math.Vector()

    ' Speed of this entity
    velocity as BGE.Math.Vector = new BGE.Math.Vector()

    ' Rotation of entity - applies to all images
    rotation as BGE.Math.Vector = new BGE.Math.Vector()


    ' Scale of entity - applies to all images
    scale as BGE.Math.Vector = BGE.Math.createScaleVector(1)

    ' The colliders for this entity by name
    colliders as roAssociativeArray = {}
    ' The array of images to draw for this entity
    images as Drawable[] = []
    ' Associative array of images by name
    imagesByName as roAssociativeArray = {}

    ' Game Entities can be tagged with any number of tags so they can be easily identified (e.g. "enemy", "wall", etc.)
    tagsList as BGE.TagList = new BGE.TagList()

    ' The Current Transformation Matrix
    transformationMatrix as BGE.Math.Matrix44 = new BGE.Math.Matrix44()

    motionChecker as MotionChecker = new MotionChecker()

    private hasDrawnDebug = false

    ' Creates a new GameEntity
    '
    ' @param {Game} game - The game engine that this entity is going to be assigned to
    ' @param {roAssociativeArray} [args={}] Any extra properties to be added to this entity
    function new(game as Game, args = {} as roAssociativeArray)
      m.game = game
      m.id = m.game.getNextGameEntityId()
      m.append(args)
    end function


    ' Is this still a valid entity?
    '
    ' @return {boolean} - true if still valid
    function isValid() as boolean
      return m.id <> invalid
    end function


    ' Marks this entity as invalid, so it will be cleared/destroyed at the end of the frame
    private sub invalidate()
      m.id = invalid
      for each image in m.images
        image.removeFromScene(m.game.canvas.renderer)
      end for
      m.images = []
      m.imagesByName = {}
    end sub


    ' Method to be called when this entity is added to a Game.
    ' Override in subclass
    '
    ' @param {object} args
    sub onCreate(args as roAssociativeArray)
    end sub


    ' Method for handling any updates based on time since previous frame
    '
    ' @param {float} deltaTime - milliseconds since last frame
    sub onUpdate(deltaTime as float)
    end sub



    ' Method for processing all collisions
    '
    ' @param {Collider} collider - the collider of this entity that collided
    ' @param {Collider} otherCollider - the collider of the other entity in the collision
    ' @param {GameEntity} otherEntity - the entity that owns the other collider
    sub onCollision(collider as Collider, otherCollider as Collider, otherEntity as GameEntity)
    end sub


    ' Method called each frame before drawing any images of this entity
    '
    ' @param {renderer} Renderer - the Renderer images will be drawn to
    sub onDrawBegin(renderer as Renderer)
    end sub


    ' Method called each frame after drawing all images of this entity
    '
    ' @param {Renderer} canvas - the Renderer images were drawn to
    sub onDrawEnd(renderer as Renderer)
    end sub


    ' Method to process input per frame
    '
    ' @param {GameInput} input - GameInput object for the last frame
    sub onInput(input as GameInput)
    end sub


    ' Method to process an ECP keyboard event
    ' @see  https://developer.roku.com/en-ca/docs/developer-program/debugging/external-control-api.md
    '
    ' @param {integer} char
    sub onECPKeyboard(char as integer)
    end sub


    ' Method to process an External Control Protocol event
    ' @see  https://developer.roku.com/en-ca/docs/references/brightscript/events/roinputevent.md
    '
    ' @param {roInputEvent} data
    sub onECPInput(data as roInputEvent)
    end sub


    ' Method to handle audio events
    ' @see  https://developer.roku.com/en-ca/docs/references/brightscript/events/roaudioplayerevent.md
    '
    ' @param {roAudioPlayerEvent} msg - roAudioPlayerEvent
    sub onAudioEvent(msg as roAudioPlayerEvent)
    end sub


    ' Called when the game pauses
    '
    sub onPause()
    end sub


    ' Called when the game unpauses
    '
    ' @param {integer} pauseTimeMs - The number of milliseconds the game was paused
    sub onResume(pauseTimeMs as integer)
    end sub


    ' Called on url event
    ' @see  https://developer.roku.com/en-ca/docs/references/brightscript/events/rourlevent.md
    '
    ' @param {roUrlEvent} msg - roUrlEvent
    sub onUrlEvent(msg as roUrlEvent)
    end sub


    ' General purpose event handler for in-game events.
    '
    ' @param {string} eventName - Event name that describes the event type
    ' @param {roAssociativeArray} data - Any extra data to go along with the event
    sub onGameEvent(eventName as string, data as roAssociativeArray)
    end sub



    ' Method called when the current room changes.
    ' This method is only called when the entity is marked as `persistant`,
    ' otherwise entities are destroyed on room changes.
    '
    ' @param {Room} newRoom - The next room
    sub onChangeRoom(newRoom as Room)
    end sub


    ' Method called when this entity is destroyed
    '
    sub onDestroy()
    end sub


    ' Adds a circle collider to this entity
    '
    ' @param {string} colliderName - Name of the collider (only one collider with the same name can be added)
    ' @param {float} radius - radius of the circle
    ' @param {float} [offset_x=0] - horizontal offset from entity position of centre of the circle
    ' @param {float} [offset_y=0] - vertical offset from entity position of centre of the circle
    ' @param {boolean} [enabled=true] - is this collider enabled?
    ' @return {object}  - the collider that was added, or `invalid` if it could not be added
    function addCircleCollider(colliderName as string, radius as float, offset_x = 0 as float, offset_y = 0 as float, enabled = true as boolean) as CircleCollider
      circCollider = new CircleCollider(colliderName, {
        enabled: enabled,
        radius: radius,
        offset: new BGE.Math.Vector(offset_x, offset_y)
      })
      return m.addCollider(circCollider) as CircleCollider
    end function


    ' Adds a rectangle collider to this entity
    '
    ' @param {string} colliderName - Name of the collider (only one collider with the same name can be added)
    ' @param {float} width - Width of rectangle
    ' @param {float} height - Height of rectangle
    ' @param {float} [offset_x=0] - horizontal offset from entity position of top left point of rectangle
    ' @param {float} [offset_y=0] - vertical offset from entity position of top left point of rectangle
    ' @param {boolean} [enabled=true] - is this collider enabled?
    ' @return {object}  - the collider that was added, or `invalid` if it could not be added
    function addRectangleCollider(colliderName as string, width as float, height as float, offset_x = 0 as float, offset_y = 0 as float, enabled = true as boolean) as RectangleCollider
      rectCollider = new RectangleCollider(colliderName, {
        enabled: enabled,
        offset: new BGE.Math.Vector(offset_x, offset_y)
        width: width,
        height: height
      })
      return m.addCollider(rectCollider) as RectangleCollider
    end function


    ' Adds a collider that has already been constructed
    '
    ' @param {Collider} colliderToAdd - the collider to add  (only one collider with the same name can be added)
    ' @return {Collider}  - the collider that was added, or `invalid` if it could not be added
    function addCollider(colliderToAdd as Collider) as Collider
      colliderName = colliderToAdd.name
      colliderToAdd.setupCompositor(m.game, m.name, m.id, m.position)
      if m.colliders[colliderName] = invalid
        m.colliders[colliderName] = colliderToAdd
      else
        print "addCollider() - Collider Name Already Exists: " + colliderName
        return invalid
      end if
      return colliderToAdd
    end function


    ' Gets a collider based on its name
    '
    ' @param {string} colliderName - The name of the collider to find
    ' @return {Collider} - the collider (if found) otherwise `invalid`
    function getCollider(colliderName as string) as Collider
      if invalid <> m.colliders[colliderName]
        return m.colliders[colliderName]
      else
        return invalid
      end if
    end function


    ' Removes a collider by its name
    '
    ' @param {string} colliderName - the name of the collider to remove
    sub removeCollider(colliderName as string)
      if m.colliders[colliderName] <> invalid
        if type(m.colliders[colliderName].compositorObject) = "roSprite"
          m.colliders[colliderName].compositorObject.Remove()
        end if
        m.colliders.Delete(colliderName)
      end if
    end sub


    ' Remove all colliders from this entity
    '
    sub clearAllColliders()
      if invalid <> m.colliders
        for each colliderKey in m.colliders
          m.removeCollider(colliderKey)
        end for
      end if
    end sub




    ' Adds a basic image (non-animated) to be drawn for this entity
    '
    ' @param {string} imageName - Name of the image
    ' @param {object} region - an `roRegion` of a bitmap to draw
    ' @param {object} [args={}] - any extra properties to set (e.g. offset_x, offset_y, rotation, scale_x, scale_y, etc.)
    ' @param {integer} [insertPosition=-1] - the position/order in the images array where the image should be added (defaults to being added at the end)
    ' @return {Image} - The image object that was added, or `invalid` if there was an error
    function addImage(imageName as string, region as roRegion, args = {} as roAssociativeArray, insertPosition = -1 as integer) as Image
      imageObject = new Image(m, m.game.getCanvas(), region, args) 'm as first arg
      return m.addImageObject(imageName, imageObject, insertPosition) as Image
    end function


    ' Adds a animated image to be drawn for this entity. Animated images cycle through regions of a bitmap (e.g. spritesheet)
    '
    ' @param {string} imageName - Name of the image
    ' @param {roRegion[]} regions - an array of `roRegion` of a bitmap to draw
    ' @param {object} [args={}] - any extra properties to set (e.g. offset_x, offset_y, rotation, scale_x, scale_y, etc.)
    ' @param {integer} [insertPosition=-1] - the position/order in the images array where the image should be added (defaults to being added at the end)
    ' @return {AnimatedImage} - The image object that was added, or `invalid` if there was an error
    function addAnimatedImage(imageName as string, regions as roRegion[], args = {} as roAssociativeArray, insertPosition = -1 as integer) as AnimatedImage
      imageObject = new AnimatedImage(m, m.game.getCanvas(), regions, args)
      return m.addImageObject(imageName, imageObject, insertPosition) as AnimatedImage
    end function


    ' Adds a Sprite to be drawn for this entity. Sprites can have specific animations configured buy choosing series of cells from a sprite sheet
    '
    ' @param {string} imageName - Name of the image
    ' @param {roBitmap} bitmap - the bitmap object to use for teh SpriteSheet (e.g response from game.getBitmap("bitmap_name"))
    ' @param {integer} cellWidth - the height in pixels of a dingle cell in the sprite
    ' @param {integer} cellHeight - the height in pixels of a dingle cell in the sprite
    ' @param {object} [args={}] - any extra properties to set (e.g. offset_x, offset_y, rotation, scale_x, scale_y, etc.)
    ' @param {integer} [insertPosition=-1] - the position/order in the images array where the image should be added (defaults to being added at the end)
    ' @return {Sprite} - The image object that was added, or `invalid` if there was an error
    function addSprite(imageName as string, spriteSheet as roBitmap, cellWidth as integer, cellHeight as integer, args = {} as roAssociativeArray, insertPosition = -1 as integer) as Sprite
      imageObject = new Sprite(m, m.game.getCanvas(), spriteSheet, cellWidth, cellHeight, args)
      return m.addImageObject(imageName, imageObject, insertPosition) as Sprite
    end function


    ' Adds any Image object to this entity
    '
    ' @param {string} imageName - Name of the image
    ' @param {Drawable} drawableObject - The image to be added
    ' @param {integer} [insertPosition=-1] - the position/order in the images array where the image should be added (defaults to being added at the end)
    ' @return {Drawable} - The image object that was added, or `invalid` if there was an error
    function addImageObject(imageName as string, drawableObject as Drawable, insertPosition = -1 as integer) as Drawable
      drawableObject.name = imageName

      if m.getImage(drawableObject.name) <> invalid
        print "addImageObject() - An image named - " + drawableObject.name + " - already exists"
        return invalid
      end if

      m.imagesByName[drawableObject.name] = drawableObject
      if insertPosition = -1
        m.images.Push(drawableObject)
      else if insertPosition = 0
        m.images.Unshift(drawableObject)
      else if insertPosition < m.images.Count()
        BGE.ArrayInsert(m.images, insertPosition, drawableObject)
      else
        m.images.Push(drawableObject)
      end if
      drawableObject.addToScene(m.game.canvas.renderer)
      return drawableObject
    end function


    ' Gets an image by its name from the lookup table
    '
    ' @param {string} imageName - Name of image to get
    ' @return {Drawable}
    function getImage(imageName as string) as Drawable
      return m.imagesByName[imageName]
    end function


    ' Removes an image from the entity
    '
    ' @param {string} imageName - Name of image to remove
    sub removeImage(imageName as string)
      m.imagesByName.Delete(imageName)
      if m.images.Count() > 0
        for i = 0 to m.images.Count() - 1
          if m.images[i].name = imageName
            m.images[i].removeFromScene(m.game.canvas.renderer)
            m.images.Delete(i)
            exit for
          end if
        end for
      end if
    end sub


    sub updateTransformationMatrix()
      currentlyMoved = m.motionChecker.check(m.position, m.rotation, m.scale)

      if m.movedLastFrame() and not currentlyMoved
        m.motionChecker.resetMovedFlag()
        return
      end if

      if currentlyMoved
        m.motionChecker.setTransform(m.position, m.rotation, m.scale)
        m.transformationMatrix.setFrom(BGE.Math.getTransformationMatrix(m.position, m.rotation, m.scale))
      end if
    end sub

    function movedLastFrame() as boolean
      return m.motionChecker.movedLastFrame
    end function

    ' TODO: work on statics
    '
    ' @param {string} staticVariableName
    ' @return {dynamic}
    function getStaticVariable(staticVariableName as string) as dynamic
      if invalid <> m.game.Statics[m.name] and invalid <> m.game.Statics[m.name][staticVariableName]
        return m.game.Statics[m.name][staticVariableName]
      else
        return invalid
      end if
    end function


    ' TODO: work on statics
    '
    ' @param {string} staticVariableName
    ' @param {dynamic} staticVariableValue
    sub setStaticVariable(staticVariableName as string, staticVariableValue as dynamic)
      if invalid <> m.game.Statics[m.name]
        m.game.Statics[m.name][staticVariableName] = staticVariableValue
      end if
    end sub


    ' TODO: work on Interfaces
    '
    ' @param {string} interfaceName
    sub addInterface(interfaceName as string)
      interfaceObj = {owner: m}
      m.game.Interfaces[interfaceName](interfaceObj)
      m[interfaceName] = interfaceObj
    end sub


    ' TODO: work on Interfaces
    '
    ' @param {string} interfaceName
    ' @return {boolean}
    function hasInterface(interfaceName as string) as boolean
      return (m[interfaceName] <> invalid)
    end function


    ' Draws the entity's axes and/or its name
    sub debugDraw(renderObj as Renderer, drawAxes = false, drawName = false)
      if m.hasDrawnDebug
        drawPosition = renderObj.worldPointToCanvasPoint(m.position)
        if drawAxes and invalid <> drawPosition
          axesSize = 50
          dotSize = 10

          xAxisEnd = renderObj.worldPointToCanvasPoint(m.transformationMatrix.multVecMatrix(new BGE.Math.Vector(axesSize, 0, 0)))
          yAxisEnd = renderObj.worldPointToCanvasPoint(m.transformationMatrix.multVecMatrix(new BGE.Math.Vector(0, axesSize, 0)))
          zAxisEnd = renderObj.worldPointToCanvasPoint(m.transformationMatrix.multVecMatrix(new BGE.Math.Vector(0, 0, axesSize)))

          if invalid <> xAxisEnd and invalid <> yAxisEnd and invalid <> zAxisEnd
            renderObj.drawSquare(drawPosition.x, drawPosition.y, dotSize, BGE.Colors().Pink)
            renderObj.drawLine(drawPosition.x, drawPosition.y, xAxisEnd.x, xAxisEnd.y, BGE.Colors().Red)
            renderObj.drawLine(drawPosition.x, drawPosition.y, yAxisEnd.x, yAxisEnd.y, BGE.Colors().Green)
            renderObj.drawLine(drawPosition.x, drawPosition.y, zAxisEnd.x, zAxisEnd.y, BGE.Colors().Blue)
          end if
        end if

        if drawName and invalid <> drawPosition
          offset = 10
          renderObj.drawText(m.name, drawPosition.x + offset, drawPosition.y + offset, BGE.Colors().Cyan, m.game.getFont("debugUiSmall"))
        end if
      end if
      m.hasDrawnDebug = true
    end sub

  end class
end namespace
